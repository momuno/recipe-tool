{
  "timestamp": "2025-09-11T16:08:13.365655",
  "snapshots": {
    "apps/document-generator/document_generator_app": {
      "type": "directory"
    },
    "apps/document-generator/document_generator_app/app.py": {
      "content": "import argparse\nimport asyncio\nimport json\nimport os\nimport tempfile\nimport time\nimport uuid\nfrom pathlib import Path\nfrom typing import Any, Dict, List\n\nimport gradio as gr\nimport pypandoc\nimport requests\nfrom bs4 import BeautifulSoup\nfrom docx import Document\nfrom docpack_file import DocpackHandler\nfrom dotenv import load_dotenv\n\nfrom .executor.runner import generate_docpack_from_prompt, generate_document\nfrom .models.outline import Outline, Resource, Section\nfrom .session import session_manager\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Global variable to track if app is running in dev mode\nIS_DEV_MODE = False\n\n# Supported file types for uploads\nSUPPORTED_FILE_TYPES = [\n    \".txt\",\n    \".md\",\n    \".py\",\n    \".c\",\n    \".cpp\",\n    \".h\",\n    \".java\",\n    \".js\",\n    \".ts\",\n    \".jsx\",\n    \".tsx\",\n    \".json\",\n    \".xml\",\n    \".yaml\",\n    \".yml\",\n    \".toml\",\n    \".ini\",\n    \".cfg\",\n    \".conf\",\n    \".sh\",\n    \".bash\",\n    \".zsh\",\n    \".fish\",\n    \".ps1\",\n    \".bat\",\n    \".cmd\",\n    \".rs\",\n    \".go\",\n    \".rb\",\n    \".php\",\n    \".pl\",\n    \".lua\",\n    \".r\",\n    \".m\",\n    \".swift\",\n    \".kt\",\n    \".scala\",\n    \".clj\",\n    \".ex\",\n    \".exs\",\n    \".elm\",\n    \".fs\",\n    \".ml\",\n    \".sql\",\n    \".html\",\n    \".htm\",\n    \".css\",\n    \".scss\",\n    \".sass\",\n    \".less\",\n    \".vue\",\n    \".svelte\",\n    \".astro\",\n    \".tex\",\n    \".rst\",\n    \".adoc\",\n    \".org\",\n    \".csv\",\n    \".docx\",\n]\n\n\ndef markdown_to_docx(markdown_content: str, output_path: str) -> str:\n    \"\"\"Convert markdown content to docx file and return the output path.\"\"\"\n    try:\n        pypandoc.convert_text(\n            markdown_content,\n            \"docx\",\n            format=\"md\",\n            outputfile=output_path,\n            extra_args=[\"--extract-media=.\"],  # Extract images to current directory\n        )\n        return output_path\n    except Exception as e:\n        raise Exception(f\"Failed to convert markdown to docx: {str(e)}\")\n\n\ndef check_docx_protected(docx_path: str) -> tuple[bool, str]:\n    \"\"\"Check if a docx file is protected/encrypted without fully extracting text.\n    Returns (is_protected, error_message)\n    \"\"\"\n    try:\n        from docx import Document\n\n        filename = os.path.basename(docx_path)\n        # Try to open the document\n        doc = Document(docx_path)\n        # Try to access at least one paragraph to ensure it's readable\n        _ = len(doc.paragraphs)\n        return False, \"\"\n    except Exception as e:\n        error_msg = str(e).lower()\n        filename = os.path.basename(docx_path)\n        # Check for common security/encryption error messages\n        if any(term in error_msg for term in [\"package not found\"]):\n            return True, (f\"Document '{filename}' appears to be protected or encrypted and cannot be processed.\")\n        else:\n            # Some other error, but not protection-related\n            return False, f\"Document '{filename}' may have issues: {str(e)}\"\n\n\ndef docx_to_text(docx_path: str) -> str:\n    \"\"\"Extract text content from a docx file.\"\"\"\n    try:\n        doc = Document(docx_path)\n        paragraphs = []\n\n        for paragraph in doc.paragraphs:\n            if paragraph.text.strip():  # Only add non-empty paragraphs\n                paragraphs.append(paragraph.text.strip())\n\n        return \"\\n\\n\".join(paragraphs)\n    except Exception as e:\n        error_msg = str(e).lower()\n        filename = os.path.basename(docx_path)\n        # Check for common security/encryption error messages\n        if any(term in error_msg for term in [\"package not found\"]):\n            raise Exception(f\"Document '{filename}' may be protected or encrypted and cannot be processed.\")\n        else:\n            raise Exception(f\"Failed to extract text from '{filename}': {str(e)}\")\n\n\ndef convert_github_url_to_raw(url: str) -> str:\n    \"\"\"Convert GitHub blob URLs to raw URLs for direct file access.\"\"\"\n    if \"github.com\" in url and \"/blob/\" in url:\n        # Convert github.com/user/repo/blob/branch/file to raw.githubusercontent.com/user/repo/branch/file\n        raw_url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\"/blob/\", \"/\")\n        return raw_url\n    return url\n\n\ndef extract_text_from_url(url: str) -> str:\n    \"\"\"Extract readable text content from a web URL.\"\"\"\n    try:\n        # Convert GitHub URLs to raw format for direct access\n        original_url = url\n        url = convert_github_url_to_raw(url)\n\n        # Enhanced headers to avoid bot detection\n        headers = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.5\",\n            \"Connection\": \"keep-alive\",\n        }\n\n        # Retry logic with exponential backoff\n        import time\n\n        max_retries = 3\n        response = None\n        for attempt in range(max_retries):\n            try:\n                # Add delay between requests to avoid rate limiting\n                if attempt > 0:\n                    delay = 2**attempt  # Exponential backoff: 2s, 4s, 8s\n                    print(f\"Retrying URL {url} in {delay} seconds...\")\n                    time.sleep(delay)\n\n                response = requests.get(url, headers=headers, timeout=30)\n                response.raise_for_status()\n                break\n\n            except requests.exceptions.HTTPError as e:\n                if e.response.status_code == 429 and attempt < max_retries - 1:\n                    # Rate limited, wait and retry\n                    print(f\"Rate limited (429) for {url}, retrying...\")\n                    continue\n                elif e.response.status_code == 403 and \"github\" in url and attempt == 0:\n                    # GitHub might block, try original URL\n                    print(f\"GitHub blocked raw URL, trying original URL...\")\n                    url = original_url\n                    continue\n                else:\n                    raise e\n            except requests.exceptions.RequestException as e:\n                if attempt < max_retries - 1:\n                    print(f\"Request failed for {url}, retrying...\")\n                    continue\n                else:\n                    raise e\n\n        if not response:\n            raise Exception(\"Failed to get response after all retries\")\n\n        # Check if this is a raw text file (like .md, .txt, etc.)\n        content_type = response.headers.get(\"content-type\", \"\").lower()\n        if any(t in content_type for t in [\"text/plain\", \"text/markdown\", \"text/x-markdown\"]):\n            return response.text.strip()\n\n        # Check for common text file extensions in URL\n        url_lower = url.lower()\n        if any(url_lower.endswith(ext) for ext in [\".md\", \".txt\", \".rst\", \".py\", \".js\", \".json\", \".yaml\", \".yml\"]):\n            return response.text.strip()\n\n        # Parse HTML content\n        soup = BeautifulSoup(response.content, \"html.parser\")\n\n        # Remove script and style elements\n        for script in soup([\"script\", \"style\", \"nav\", \"header\", \"footer\", \"aside\"]):\n            script.decompose()\n\n        # Try to find main content areas first\n        content = None\n        main_selectors = [\n            \"main\",\n            \"article\",\n            \".content\",\n            \"#content\",\n            \".main\",\n            \"#main\",\n            \".post\",\n            \".entry\",\n            \".article-content\",\n            \".page-content\",\n        ]\n\n        for selector in main_selectors:\n            main_content = soup.select_one(selector)\n            if main_content:\n                content = main_content.get_text()\n                break\n\n        # If no main content found, use body\n        if not content:\n            content = soup.get_text()\n\n        # Clean up the text\n        lines = (line.strip() for line in content.splitlines())\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n        text = \" \".join(chunk for chunk in chunks if chunk)\n\n        # Remove excessive whitespace\n        import re\n\n        text = re.sub(r\"\\s+\", \" \", text).strip()\n\n        if not text:\n            raise Exception(\"No readable content found on the page\")\n\n        return text\n\n    except requests.exceptions.RequestException as e:\n        raise Exception(f\"Failed to fetch URL: {str(e)}\")\n    except Exception as e:\n        raise Exception(f\"Failed to extract content from URL: {str(e)}\")\n\n\ndef download_urls_to_temp(urls: str, temp_dir: str) -> List[Dict[str, str]]:\n    \"\"\"Download content from comma-separated URLs to temp directory.\n\n    Args:\n        urls: Comma-separated string of URLs\n        temp_dir: Directory to save downloaded files\n\n    Returns:\n        List of resource dictionaries with path, name, and size info\n    \"\"\"\n    if not urls.strip():\n        return []\n\n    url_list = [url.strip() for url in urls.split(\",\") if url.strip()]\n    resources = []\n    errors = []\n\n    for url in url_list:\n        try:\n            # Validate URL format\n            if not url.startswith((\"http://\", \"https://\")):\n                url = \"https://\" + url\n\n            # Extract content\n            content = extract_text_from_url(url)\n\n            # Create filename from URL\n            from urllib.parse import urlparse\n\n            parsed = urlparse(url)\n            domain = parsed.netloc.replace(\"www.\", \"\")\n            path_part = parsed.path.strip(\"/\").replace(\"/\", \"_\")\n\n            if path_part:\n                filename = f\"{domain}_{path_part}.txt\"\n            else:\n                filename = f\"{domain}.txt\"\n\n            # Ensure filename is valid\n            import re\n\n            filename = re.sub(r\"[^\\w\\-_.]\", \"_\", filename)\n\n            # Write content to temp file\n            file_path = os.path.join(temp_dir, filename)\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(content)\n\n            # Calculate file size\n            file_size = os.path.getsize(file_path)\n            if file_size < 1024:\n                size_str = f\"{file_size} B\"\n            elif file_size < 1024 * 1024:\n                size_str = f\"{file_size / 1024:.1f} KB\"\n            else:\n                size_str = f\"{file_size / (1024 * 1024):.1f} MB\"\n\n            resources.append({\n                \"path\": file_path,\n                \"name\": filename,\n                \"size\": size_str,\n                \"url\": url,  # Keep original URL for reference\n                \"resource_type\": \"url\",  # Mark as URL resource\n                \"source_url\": url,  # Store source URL\n            })\n\n        except Exception as e:\n            errors.append(f\"{url}: {str(e)}\")\n\n    if errors:\n        error_msg = \"Some URLs failed to download:\\n\" + \"\\n\".join(errors)\n        if not resources:\n            # If all URLs failed\n            raise Exception(error_msg)\n        else:\n            # If some succeeded, log the errors but continue\n            print(f\"URL download warnings: {error_msg}\")\n\n    return resources\n\n\ndef json_to_outline(json_data: Dict[str, Any]) -> Outline:\n    \"\"\"Convert JSON structure to Outline dataclasses.\"\"\"\n    # Create outline with basic metadata\n    outline = Outline(title=json_data.get(\"title\", \"\"), general_instruction=json_data.get(\"general_instruction\", \"\"))\n\n    # Convert resources\n    for res_data in json_data.get(\"resources\", []):\n        # Handle backward compatibility - use filename as title if title not present\n        title = res_data.get(\"title\", \"\")\n        if not title:\n            # Extract filename from path as default title\n            title = os.path.basename(res_data[\"path\"])\n\n        resource = Resource(\n            key=res_data[\"key\"],\n            path=res_data[\"path\"],\n            title=title,\n            description=res_data[\"description\"],\n            merge_mode=\"concat\",  # Default merge mode\n        )\n        outline.resources.append(resource)\n\n    # Helper function to convert sections recursively\n    def convert_sections(sections_data: List[Dict[str, Any]]) -> List[Section]:\n        sections = []\n        for sec_data in sections_data:\n            section = Section(title=sec_data.get(\"title\", \"\"))\n\n            # Check if it has prompt (AI block) or resource_key (text block)\n            if \"prompt\" in sec_data:\n                # AI block\n                section.prompt = sec_data[\"prompt\"]\n                section.refs = sec_data.get(\"refs\", [])\n                section._mode = None  # Default mode\n            elif \"resource_key\" in sec_data:\n                # Text block\n                section.resource_key = sec_data[\"resource_key\"]\n                section._mode = \"Static\"\n\n            # Convert nested sections\n            if \"sections\" in sec_data:\n                section.sections = convert_sections(sec_data[\"sections\"])\n\n            sections.append(section)\n\n        return sections\n\n    # Convert top-level sections\n    outline.sections = convert_sections(json_data.get(\"sections\", []))\n\n    return outline\n\n\ndef add_ai_block(blocks, focused_block_id=None):\n    \"\"\"Add an AI content block.\"\"\"\n    new_block = {\n        \"id\": str(uuid.uuid4()),\n        \"type\": \"ai\",\n        \"heading\": \"\",\n        \"content\": \"\",\n        \"resources\": [],\n        \"collapsed\": True,  # Start collapsed\n        \"indent_level\": 0,\n    }\n\n    # If no focused block or focused block not found, add at the end\n    if not focused_block_id:\n        return blocks + [new_block]\n\n    # Find the focused block and insert after it\n    for i, block in enumerate(blocks):\n        if block[\"id\"] == focused_block_id:\n            # Inherit the indent level from the focused block\n            new_block[\"indent_level\"] = block.get(\"indent_level\", 0)\n            # Insert after the focused block\n            return blocks[: i + 1] + [new_block] + blocks[i + 1 :]\n\n    # If focused block not found, add at the end\n    return blocks + [new_block]\n\n\ndef add_heading_block(blocks):\n    \"\"\"Add a heading block.\"\"\"\n    new_block = {\"id\": str(uuid.uuid4()), \"type\": \"heading\", \"content\": \"Heading\"}\n    return blocks + [new_block]\n\n\ndef add_text_block(blocks, focused_block_id=None):\n    \"\"\"Add a text block.\"\"\"\n    new_block = {\n        \"id\": str(uuid.uuid4()),\n        \"type\": \"text\",\n        \"heading\": \"\",\n        \"content\": \"\",\n        \"resources\": [],\n        \"collapsed\": True,  # Start collapsed\n        \"indent_level\": 0,\n    }\n\n    # If no focused block or focused block not found, add at the end\n    if not focused_block_id:\n        return blocks + [new_block]\n\n    # Find the focused block and insert after it\n    for i, block in enumerate(blocks):\n        if block[\"id\"] == focused_block_id:\n            # Inherit the indent level from the focused block\n            new_block[\"indent_level\"] = block.get(\"indent_level\", 0)\n            # Insert after the focused block\n            return blocks[: i + 1] + [new_block] + blocks[i + 1 :]\n\n    # If focused block not found, add at the end\n    return blocks + [new_block]\n\n\ndef delete_block(blocks, block_id, title, description, resources):\n    \"\"\"Delete a block by its ID and regenerate outline.\"\"\"\n    blocks = [block for block in blocks if block[\"id\"] != block_id]\n\n    # Regenerate outline JSON\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef update_block_content(blocks, block_id, content, title, description, resources):\n    \"\"\"Update the content of a specific block and regenerate outline.\"\"\"\n    for block in blocks:\n        if block[\"id\"] == block_id:\n            block[\"content\"] = content\n            # Also save to type-specific field\n            if block[\"type\"] == \"ai\":\n                block[\"ai_content\"] = content\n            elif block[\"type\"] == \"text\":\n                block[\"text_content\"] = content\n                # Mark text block as edited when content changes\n                if content:\n                    block[\"edited\"] = True\n                    # Store original resource reference if exists\n                    if \"resources\" in block and block[\"resources\"]:\n                        block[\"original_resource\"] = block[\"resources\"][0]\n                        block[\"resources\"] = []  # Clear resources since content is now edited\n            break\n\n    # Regenerate outline JSON\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef update_block_heading(blocks, block_id, heading, title, description, resources):\n    \"\"\"Update the heading of a specific block and regenerate outline.\"\"\"\n    for block in blocks:\n        if block[\"id\"] == block_id:\n            block[\"heading\"] = heading\n            break\n\n    # Regenerate outline and JSON\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef set_focused_block(block_id):\n    \"\"\"Set the currently focused block.\"\"\"\n    return block_id\n\n\ndef reset_document(session_id=None):\n    \"\"\"Reset the document to initial empty state.\"\"\"\n    # Create new session ID\n    new_session_id = str(uuid.uuid4())\n\n    # Reset to initial blocks\n    initial_blocks = [\n        {\n            \"id\": str(uuid.uuid4()),\n            \"type\": \"ai\",\n            \"heading\": \"\",\n            \"content\": \"\",\n            \"resources\": [],\n            \"collapsed\": False,  # AI block starts expanded\n            \"indent_level\": 0,\n        },\n        {\n            \"id\": str(uuid.uuid4()),\n            \"type\": \"text\",\n            \"heading\": \"\",\n            \"content\": \"\",\n            \"resources\": [],\n            \"collapsed\": True,  # Text block starts collapsed\n            \"indent_level\": 0,\n        },\n    ]\n\n    # Generate initial outline\n    json_str = generate_outline_json_from_state(\"\", \"\", [], initial_blocks)\n\n    # Return empty title, description, empty resources, initial blocks\n    return (\n        gr.update(value=\"\"),  # title - use gr.update to ensure proper clearing\n        gr.update(value=\"\"),  # description - use gr.update to ensure proper clearing\n        [],  # resources\n        initial_blocks,  # blocks\n        json_str,  # json_output\n        None,  # import_file\n        new_session_id,  # session_id\n        gr.update(\n            value=\"<em>Click '\u25b7 Generate' to see the generated content here.</em><br><br><br>\", visible=True\n        ),  # generated_content_html\n        gr.update(visible=False),  # generated_content\n        gr.update(interactive=False),  # save_doc_btn\n    )\n\n\ndef convert_block_type(blocks, block_id, to_type, title, description, resources):\n    \"\"\"Convert a block from one type to another while preserving separate content for each type.\"\"\"\n    for block in blocks:\n        if block[\"id\"] == block_id:\n            current_type = block[\"type\"]\n\n            # Save current content to type-specific field\n            if current_type == \"ai\":\n                block[\"ai_content\"] = block.get(\"content\", \"\")\n                block[\"ai_resources\"] = block.get(\"resources\", [])\n            elif current_type == \"text\":\n                block[\"text_content\"] = block.get(\"content\", \"\")\n                block[\"text_resources\"] = block.get(\"resources\", [])\n\n            # Switch to new type\n            block[\"type\"] = to_type\n\n            # Load content for the new type\n            if to_type == \"ai\":\n                block[\"content\"] = block.get(\"ai_content\", \"\")\n                block[\"resources\"] = block.get(\"ai_resources\", [])\n            elif to_type == \"text\":\n                block[\"content\"] = block.get(\"text_content\", \"\")\n                block[\"resources\"] = block.get(\"text_resources\", [])\n\n            # Ensure all required fields exist\n            if \"heading\" not in block:\n                block[\"heading\"] = \"\"\n            if \"collapsed\" not in block:\n                block[\"collapsed\"] = False\n            if \"indent_level\" not in block:\n                block[\"indent_level\"] = 0\n            break\n\n    # Regenerate outline JSON\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef toggle_block_collapse(blocks, block_id):\n    \"\"\"Toggle the collapsed state of a specific block.\"\"\"\n    for block in blocks:\n        if block[\"id\"] == block_id:\n            # Simply toggle the collapsed state\n            block[\"collapsed\"] = not block.get(\"collapsed\", False)\n            break\n    return blocks\n\n\ndef update_block_indent(blocks, block_id, direction, title, description, resources):\n    \"\"\"Update the indent level of a specific block and regenerate outline.\"\"\"\n    # Find the index of the block being modified\n    block_index = None\n    for i, block in enumerate(blocks):\n        if block[\"id\"] == block_id:\n            block_index = i\n            break\n\n    if block_index is None:\n        json_str = generate_outline_json_from_state(title, description, resources, blocks)\n        return blocks, json_str\n\n    block = blocks[block_index]\n    current_level = block.get(\"indent_level\", 0)\n\n    if direction == \"in\":\n        # Check if this is the first block - if so, can't indent at all\n        if block_index == 0:\n            json_str = generate_outline_json_from_state(title, description, resources, blocks)\n            return blocks, json_str\n\n        # Get the previous block's indent level\n        prev_block = blocks[block_index - 1]\n        prev_level = prev_block.get(\"indent_level\", 0)\n        max_allowed_level = prev_level + 1\n\n        # Can only indent if current level is less than max allowed and less than 5\n        if current_level < max_allowed_level and current_level < 5:\n            block[\"indent_level\"] = current_level + 1\n    elif direction == \"out\" and current_level > 0:\n        block[\"indent_level\"] = current_level - 1\n\n    # Regenerate outline JSON\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef save_inline_resources(blocks, output_dir):\n    \"\"\"Save inline resources from edited text blocks to disk.\"\"\"\n    saved_resources = []\n    for block in blocks:\n        if block.get(\"type\") == \"text\" and block.get(\"edited\") and block.get(\"text_content\"):\n            # Save the inline resource\n            filename = f\"inline_{block['id']}.txt\"\n            filepath = Path(output_dir) / filename\n            filepath.write_text(block[\"text_content\"], encoding=\"utf-8\")\n            saved_resources.append({\"block_id\": block[\"id\"], \"path\": str(filepath)})\n    return saved_resources\n\n\nasync def handle_document_generation(title, description, resources, blocks, session_id=None):\n    \"\"\"Generate document using the recipe executor.\"\"\"\n    json_str = \"\"  # Initialize json_str before the try block\n    try:\n        # Get or create session ID\n        if not session_id:\n            session_id = str(uuid.uuid4())\n\n        # Use session temp directory for inline resources and output\n        temp_dir = session_manager.get_temp_dir(session_id)\n\n        # Generate the JSON with inline resources saved to temp directory\n        json_str = generate_document_json(title, description, resources, blocks, save_inline=True, inline_dir=temp_dir)\n        json_data = json.loads(json_str)\n\n        # Remove is_inline flags for compatibility with json_to_outline\n        for res in json_data.get(\"resources\", []):\n            if \"is_inline\" in res:\n                del res[\"is_inline\"]\n\n        # Convert to Outline\n        outline = json_to_outline(json_data)\n\n        # Generate the document\n        generated_content = await generate_document(outline, session_id, IS_DEV_MODE)\n\n        # Save both DOCX and Markdown versions\n        base_filename = title if title else \"document\"\n\n        # Save as DOCX\n        docx_filename = f\"{base_filename}.docx\"\n        docx_file_path = os.path.join(temp_dir, docx_filename)\n        markdown_to_docx(generated_content, docx_file_path)\n        print(f\"DEBUG: Created DOCX file at: {docx_file_path}\")\n\n        # Save as Markdown\n        markdown_filename = f\"{base_filename}.md\"\n        markdown_file_path = os.path.join(temp_dir, markdown_filename)\n        with open(markdown_file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(generated_content)\n        print(f\"DEBUG: Created Markdown file at: {markdown_file_path}\")\n\n        # Verify files exist\n        if os.path.exists(docx_file_path):\n            print(f\"DEBUG: DOCX file exists, size: {os.path.getsize(docx_file_path)} bytes\")\n        if os.path.exists(markdown_file_path):\n            print(f\"DEBUG: Markdown file exists, size: {os.path.getsize(markdown_file_path)} bytes\")\n\n        return json_str, generated_content, docx_file_path, markdown_file_path\n\n    except Exception as e:\n        error_msg = f\"Error generating document: {str(e)}\"\n        return json_str, error_msg, None, None\n\n\ndef generate_document_json(title, description, resources, blocks, save_inline=False, inline_dir=None):\n    \"\"\"Generate JSON structure from document data following the example format.\n\n    Args:\n        save_inline: If True, save inline resources to inline_dir and use real paths\n        inline_dir: Directory to save inline resources to (required if save_inline=True)\n    \"\"\"\n    import json\n\n    # Create the base structure\n    doc_json = {\"title\": title, \"general_instruction\": description, \"resources\": [], \"sections\": []}\n\n    # Track inline resources that need to be added\n    inline_resources = []\n\n    # Process resources with their descriptions from the resources list\n    for idx, resource in enumerate(resources):\n        # Get description directly from the resource\n        description = resource.get(\"description\", \"\")\n        # Get title from resource or default to filename\n        title = resource.get(\"title\", resource.get(\"name\", os.path.basename(resource[\"path\"])))\n        doc_json[\"resources\"].append({\n            \"key\": f\"resource_{idx + 1}\",\n            \"path\": resource[\"path\"],\n            \"title\": title,\n            \"description\": description,\n            \"resource_type\": resource.get(\"resource_type\", \"file\"),  # Include resource type\n            \"source_url\": resource.get(\"source_url\"),  # Include source URL if present\n        })\n\n    # Helper function to build nested sections based on indentation\n    def build_nested_sections(blocks, start_idx=0, parent_level=-1):\n        sections = []\n        i = start_idx\n\n        while i < len(blocks):\n            block = blocks[i]\n            current_level = block.get(\"indent_level\", 0)\n\n            # If this block is at a lower level than parent, return\n            if current_level <= parent_level:\n                break\n\n            # If this block is at the expected level\n            if current_level == parent_level + 1:\n                if block[\"type\"] in [\"ai\", \"text\"] and (\n                    block.get(\"heading\") or block.get(\"content\") or block.get(\"resources\")\n                ):\n                    section = {\"title\": block.get(\"heading\", \"Untitled Section\")}\n\n                    # Handle AI blocks vs Text blocks differently\n                    if block[\"type\"] == \"ai\":\n                        # AI blocks always have these keys\n                        section[\"prompt\"] = block.get(\"content\", \"\")\n                        section[\"sections\"] = []  # Will be populated if there are nested sections\n\n                        # Handle refs - always include the key\n                        refs = []\n                        block_resources = block.get(\"resources\", [])\n                        if block_resources:\n                            # Find the resource keys for this block's resources\n                            for block_resource in block_resources:\n                                # Find matching resource in the global resources list\n                                for idx, resource in enumerate(resources):\n                                    if resource[\"path\"] == block_resource.get(\"path\"):\n                                        refs.append(f\"resource_{idx + 1}\")\n                                        break\n                        section[\"refs\"] = refs\n\n                    else:  # block['type'] == 'text'\n                        # Text blocks always have these keys\n                        section[\"resource_key\"] = \"\"  # Default to empty string\n                        section[\"sections\"] = []  # Will be populated if there are nested sections\n\n                        # Check if this text block has been edited\n                        if block.get(\"edited\") and block.get(\"text_content\"):\n                            # Create an inline resource for the edited content\n                            inline_resource_key = f\"inline_resource_{len(inline_resources) + 1}\"\n                            inline_resources.append({\n                                \"key\": inline_resource_key,\n                                \"content\": block[\"text_content\"],\n                                \"block_id\": block[\"id\"],\n                            })\n                            section[\"resource_key\"] = inline_resource_key\n                        else:\n                            # Handle regular file resource\n                            block_resources = block.get(\"resources\", [])\n                            if block_resources:\n                                # For text blocks, just use the first resource as resource_key\n                                for block_resource in block_resources:\n                                    # Find matching resource in the global resources list\n                                    for idx, resource in enumerate(resources):\n                                        if resource[\"path\"] == block_resource.get(\"path\"):\n                                            section[\"resource_key\"] = f\"resource_{idx + 1}\"\n                                            break\n                                    break  # Only use first resource for resource_key\n\n                    # Check if next blocks are indented under this one\n                    next_idx = i + 1\n                    if next_idx < len(blocks) and blocks[next_idx].get(\"indent_level\", 0) > current_level:\n                        # Build subsections\n                        subsections, next_idx = build_nested_sections(blocks, next_idx, current_level)\n                        if subsections:\n                            section[\"sections\"] = subsections\n                        i = next_idx - 1  # Adjust because we'll increment at the end\n\n                    sections.append(section)\n\n            i += 1\n\n        return sections, i\n\n    # Build the sections hierarchy\n    doc_json[\"sections\"], _ = build_nested_sections(blocks, 0, -1)\n\n    # Add inline resources to the resources list\n    if save_inline and inline_dir:\n        # Actually save the inline resources and use real paths\n        for inline_res in inline_resources:\n            filename = f\"inline_{inline_res['block_id']}.txt\"\n            filepath = Path(inline_dir) / filename\n            filepath.write_text(inline_res[\"content\"], encoding=\"utf-8\")\n\n            doc_json[\"resources\"].append({\n                \"key\": inline_res[\"key\"],\n                \"path\": str(filepath),\n                \"title\": filename,  # Use filename as title for inline resources\n                \"description\": \"\",  # No description for inline resources\n                \"is_inline\": True,  # Mark as inline resource\n            })\n    else:\n        # For preview, save to temp gradio directory immediately\n        import tempfile\n\n        gradio_temp_dir = Path(tempfile.gettempdir()) / \"gradio\"\n        gradio_temp_dir.mkdir(exist_ok=True)\n\n        for inline_res in inline_resources:\n            # Generate unique filename with timestamp\n            import time\n\n            timestamp = str(int(time.time() * 1000000))\n            filename = f\"inline_{inline_res['block_id']}_{timestamp}.txt\"\n            filepath = gradio_temp_dir / filename\n            filepath.write_text(inline_res[\"content\"], encoding=\"utf-8\")\n\n            doc_json[\"resources\"].append({\n                \"key\": inline_res[\"key\"],\n                \"path\": str(filepath),\n                \"title\": filename,  # Use filename as title for inline resources\n                \"description\": \"\",  # No description for inline resources\n                \"is_inline\": True,  # Mark as inline resource\n            })\n\n    return json.dumps(doc_json, indent=2)\n\n\ndef generate_outline_json_from_state(title, description, resources, blocks):\n    \"\"\"Regenerate the outline whenever any component changes.\"\"\"\n\n    json_str = generate_document_json(title, description, resources, blocks)\n\n    global current_document_state\n    current_document_state = {\"title\": title, \"outline_json\": json_str, \"blocks\": blocks}\n    print(f\"DEBUG: generate_outline_json_from_state called with title='{title}'\")\n    print(f\"DEBUG: Updated global current_document_state: {current_document_state}\")\n\n    return json_str\n\n\ndef update_document_metadata(title, description, resources, blocks):\n    \"\"\"Update document title/description and regenerate outline.\"\"\"\n    # Just regenerate the outline with new metadata\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return json_str\n\n\ndef update_block_resources(blocks, block_id, resource_json, title, description, resources):\n    \"\"\"Update a block's resources when a resource is dropped on it.\"\"\"\n    import json\n\n    # Parse the resource data\n    resource_data = json.loads(resource_json)\n\n    # Find the block and update its resources\n    for block in blocks:\n        if block[\"id\"] == block_id:\n            if \"resources\" not in block:\n                block[\"resources\"] = []\n\n            # For text blocks, only allow one resource AND auto-load content\n            if block[\"type\"] == \"text\":\n                # Replace any existing resource\n                block[\"resources\"] = [resource_data]\n\n                # Auto-load the file content into the text block\n                try:\n                    file_path = resource_data[\"path\"]\n                    if file_path.lower().endswith(\".docx\"):\n                        # Extract text from docx file\n                        block[\"content\"] = docx_to_text(file_path)\n                    else:\n                        # Read as regular text file\n                        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                            block[\"content\"] = f.read()\n                except Exception as e:\n                    print(f\"Error loading file content: {e}\")\n                    # Keep existing content if file can't be read\n            else:\n                # For AI blocks, allow multiple resources\n                # Check if resource already exists in the block\n                exists = False\n                for res in block[\"resources\"]:\n                    if res.get(\"path\") == resource_data.get(\"path\"):\n                        exists = True\n                        break\n\n                # Add resource if it doesn't exist\n                if not exists:\n                    # Check if this resource already has a description in another block\n                    existing_description = \"\"\n                    for other_block in blocks:\n                        if other_block.get(\"type\") == \"ai\" and \"resources\" in other_block:\n                            for res in other_block[\"resources\"]:\n                                if res.get(\"path\") == resource_data.get(\"path\") and res.get(\"description\"):\n                                    existing_description = res.get(\"description\", \"\")\n                                    break\n                            if existing_description:\n                                break\n\n                    # Add the resource with existing description if found\n                    resource_to_add = resource_data.copy()\n                    if existing_description:\n                        resource_to_add[\"description\"] = existing_description\n\n                    block[\"resources\"].append(resource_to_add)\n            break\n\n    # Regenerate outline\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef remove_block_resource(blocks, block_id, resource_path, title, description, resources):\n    \"\"\"Remove a resource from a block.\"\"\"\n    # Find the block and remove the resource\n    for block in blocks:\n        if block[\"id\"] == block_id:\n            if \"resources\" in block:\n                # Remove the resource with matching path\n                block[\"resources\"] = [res for res in block[\"resources\"] if res.get(\"path\") != resource_path]\n\n                # If this is a text block and we just removed its resource, clear the content\n                if block[\"type\"] == \"text\" and len(block[\"resources\"]) == 0:\n                    block[\"content\"] = \"\"\n            break\n\n    # Regenerate outline\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef update_resource_description(blocks, block_id, resource_path, description_text, title, doc_description, resources):\n    \"\"\"Update the description of a resource globally - affects all blocks using this resource.\"\"\"\n    # Update the description in ALL blocks that have this resource\n    for block in blocks:\n        if \"resources\" in block:\n            for res in block[\"resources\"]:\n                if res.get(\"path\") == resource_path:\n                    res[\"description\"] = description_text\n\n    # Regenerate outline\n    json_str = generate_outline_json_from_state(title, doc_description, resources, blocks)\n    return blocks, json_str\n\n\ndef generate_resource_html(resources):\n    \"\"\"Generate HTML for resource panel display.\"\"\"\n    if not resources:\n        return (\n            \"<p style='color: #666; font-size: 12px'>(.docx, .md, .csv, .py, .json, .txt, etc.)</p>\"\n            \"<p style='color: #666; font-size: 12px'>These reference files will be used for AI context.</p>\"\n        )\n\n    html_items = []\n    for idx, resource in enumerate(resources):\n        css_class = \"resource-item text\"\n        path = resource[\"path\"].replace(\"'\", \"\\\\'\")  # Escape single quotes\n        title = resource.get(\"title\", resource[\"name\"])\n        description = resource.get(\"description\", \"\")\n        resource_id = f\"resource-{idx}\"  # Unique ID for each resource\n\n        # Check if this is a URL resource based on resource_type or legacy url field\n        is_url_resource = resource.get(\"resource_type\") == \"url\" or \"url\" in resource\n        source_url = resource.get(\"source_url\") or resource.get(\"url\", \"\")\n\n        # Create different templates for URL vs file resources\n        if is_url_resource:\n            # URL resource template - no upload zone, has refresh button\n            html_items.append(\n                f'<div class=\"{css_class}\" id=\"{resource_id}\" draggable=\"true\" data-resource-name=\"{resource[\"name\"]}\" '\n                f'data-resource-title=\"{title}\" data-resource-type=\"url\" data-resource-path=\"{resource[\"path\"]}\" data-source-url=\"{source_url}\">'\n                f'<div class=\"resource-content\">'\n                f'<div class=\"resource-header\">'\n                f'<input type=\"text\" class=\"resource-title-input\" value=\"{title}\" '\n                f'placeholder=\"Title\" '\n                f\"oninput=\\\"updateResourceTitle('{path}', this.value)\\\" \"\n                f'onclick=\"event.stopPropagation()\" />'\n                f'<span class=\"resource-refresh\" onclick=\"refreshResourceFromPanel(\\'{path}\\', {idx})\" title=\"Refresh content from URL\">\ud83d\udd04</span>'\n                f'<span class=\"resource-delete\" onclick=\"deleteResourceFromPanel(\\'{path}\\')\">\ud83d\uddd1</span>'\n                f\"</div>\"\n                f'<div class=\"resource-description-container\">'\n                f'<textarea class=\"resource-panel-description\" '\n                f'placeholder=\"Add a description for this resource...\" '\n                f\"oninput=\\\"updateResourcePanelDescription('{path}', this.value)\\\" \"\n                f'onclick=\"event.stopPropagation()\">{description}</textarea>'\n                f'<button class=\"desc-expand-btn\" onclick=\"toggleResourceDescription(\\'{resource_id}\\')\">\u2335</button>'\n                f\"</div>\"\n                f'<div class=\"resource-filename\" title=\"{source_url}\">\ud83c\udf10 {resource[\"name\"]} (from URL)</div>'\n                f\"</div>\"\n                f\"</div>\"\n            )\n        else:\n            # File resource template - has upload zone, no refresh button\n            html_items.append(\n                f'<div class=\"{css_class}\" id=\"{resource_id}\" draggable=\"true\" data-resource-name=\"{resource[\"name\"]}\" '\n                f'data-resource-title=\"{title}\" data-resource-type=\"file\" data-resource-path=\"{resource[\"path\"]}\">'\n                f'<div class=\"resource-content\">'\n                f'<div class=\"resource-header\">'\n                f'<input type=\"text\" class=\"resource-title-input\" value=\"{title}\" '\n                f'placeholder=\"Title\" '\n                f\"oninput=\\\"updateResourceTitle('{path}', this.value)\\\" \"\n                f'onclick=\"event.stopPropagation()\" />'\n                f'<span class=\"resource-delete\" onclick=\"deleteResourceFromPanel(\\'{path}\\')\">\ud83d\uddd1</span>'\n                f\"</div>\"\n                f'<div class=\"resource-description-container\">'\n                f'<textarea class=\"resource-panel-description\" '\n                f'placeholder=\"Add a description for this resource...\" '\n                f\"oninput=\\\"updateResourcePanelDescription('{path}', this.value)\\\" \"\n                f'onclick=\"event.stopPropagation()\">{description}</textarea>'\n                f'<button class=\"desc-expand-btn\" onclick=\"toggleResourceDescription(\\'{resource_id}\\')\">\u2335</button>'\n                f\"</div>\"\n                f'<div class=\"resource-filename\">\ud83d\udcc4 {resource[\"name\"]}</div>'\n                f'<div class=\"resource-upload-zone\" data-resource-path=\"{path}\">'\n                f'<span class=\"upload-text\">Drop file here to replace</span>'\n                f'<input type=\"file\" class=\"resource-file-input\" accept=\".txt,.md,.py,.c,.cpp,.h,.java,.js,.ts,.jsx,.tsx,.json,.xml,.yaml,.yml,.toml,.ini,.cfg,.conf,.sh,.bash,.zsh,.fish,.ps1,.bat,.cmd,.rs,.go,.rb,.php,.pl,.lua,.r,.m,.swift,.kt,.scala,.clj,.ex,.exs,.elm,.fs,.ml,.sql,.html,.htm,.css,.scss,.sass,.less,.vue,.svelte,.astro,.tex,.rst,.adoc,.org,.csv,.docx\" '\n                f\"onchange=\\\"handleResourceFileUpload('{path}', this)\\\" />\"\n                f\"</div>\"\n                f\"</div>\"\n                f\"</div>\"\n            )\n\n    return \"\\n\".join(html_items)\n\n\ndef refresh_resource_from_panel(resources, resource_path, resource_index, title, description, blocks):\n    \"\"\"Refresh a URL resource from the resource panel.\"\"\"\n    print(f\"DEBUG: Refreshing resource from panel: {resource_path} at index {resource_index}\")\n\n    # Find the resource by path\n    resource = None\n    for res in resources:\n        if res.get(\"path\") == resource_path:\n            resource = res\n            break\n\n    if not resource:\n        error_msg = \"Resource not found\"\n        # Re-generate HTML for resources display\n        resources_html = generate_resource_html(resources)\n        json_str = generate_outline_json_from_state(title, description, resources, blocks)\n        return resources, blocks, json_str\n\n    # Only refresh URL resources\n    if resource.get(\"resource_type\") != \"url\" or not resource.get(\"source_url\"):\n        error_msg = \"This is not a URL resource\"\n        resources_html = generate_resource_html(resources)\n        json_str = generate_outline_json_from_state(title, description, resources, blocks)\n        return resources, blocks, json_str\n\n    try:\n        # Re-download content from the URL\n        url = resource[\"source_url\"]\n        content = extract_text_from_url(url)\n\n        # Write updated content to the same file path\n        with open(resource[\"path\"], \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n\n        # Update file size in resource\n        file_size = os.path.getsize(resource[\"path\"])\n        if file_size < 1024:\n            size_str = f\"{file_size} B\"\n        elif file_size < 1024 * 1024:\n            size_str = f\"{file_size / 1024:.1f} KB\"\n        else:\n            size_str = f\"{file_size / (1024 * 1024):.1f} MB\"\n\n        # Update the resource info\n        resource[\"size\"] = size_str\n\n        # Re-generate HTML for resources display\n        resources_html = generate_resource_html(resources)\n\n        # Regenerate outline with updated resources\n        json_str = generate_outline_json_from_state(title, description, resources, blocks)\n\n        print(f\"DEBUG: Successfully refreshed URL resource: {resource['name']}\")\n        return resources, blocks, json_str, resources_html, None  # No error\n\n    except Exception as e:\n        error_msg = f\"Failed to refresh URL content: {str(e)}\"\n        print(f\"ERROR: {error_msg}\")\n\n        # Still regenerate the display\n        resources_html = generate_resource_html(resources)\n        json_str = generate_outline_json_from_state(title, description, resources, blocks)\n        return resources, blocks, json_str\n\n\ndef delete_resource_from_panel(resources, resource_path, title, description, blocks):\n    \"\"\"Delete a resource from the resource panel and all blocks that use it.\"\"\"\n    print(f\"Deleting resource from panel: {resource_path}\")\n\n    # Remove from resources list\n    new_resources = [res for res in resources if res.get(\"path\") != resource_path]\n\n    # Create new blocks list to ensure state updates\n    updated_blocks = []\n    for block in blocks:\n        block_copy = block.copy()\n        if \"resources\" in block_copy:\n            # Count resources before removal\n            original_count = len(block_copy[\"resources\"])\n\n            # Remove the resource\n            block_copy[\"resources\"] = [res for res in block_copy[\"resources\"] if res.get(\"path\") != resource_path]\n\n            if original_count != len(block_copy[\"resources\"]):\n                print(\n                    f\"Removed resource from block {block_copy['id']}: {original_count} -> {len(block_copy['resources'])}\"\n                )\n\n            # If this was a text block and we removed its only resource, clear the content\n            if block_copy[\"type\"] == \"text\" and original_count > 0 and len(block_copy[\"resources\"]) == 0:\n                block_copy[\"content\"] = \"\"\n\n        updated_blocks.append(block_copy)\n\n    # Regenerate outline\n    json_str = generate_outline_json_from_state(title, description, new_resources, updated_blocks)\n\n    # Return the values expected by the handler (4 outputs)\n    return new_resources, updated_blocks, json_str\n\n\ndef update_resource_title(resources, resource_path, new_title, doc_title, doc_description, blocks):\n    \"\"\"Update the title of a resource.\"\"\"\n    # Update the title in the resources list\n    for resource in resources:\n        if resource.get(\"path\") == resource_path:\n            resource[\"title\"] = new_title\n            break\n\n    # Regenerate outline with updated resources (for JSON display)\n    json_str = generate_outline_json_from_state(doc_title, doc_description, resources, blocks)\n\n    return resources, json_str\n\n\ndef update_resource_panel_description(resources, resource_path, new_description, doc_title, doc_description, blocks):\n    \"\"\"Update the description of a resource from the panel.\"\"\"\n    # Update the description in the resources list\n    for resource in resources:\n        if resource.get(\"path\") == resource_path:\n            resource[\"description\"] = new_description\n            break\n\n    # Regenerate outline with updated resources (for JSON display)\n    json_str = generate_outline_json_from_state(doc_title, doc_description, resources, blocks)\n\n    return resources, json_str\n\n\ndef replace_resource_file(\n    resources, old_resource_path, new_file_path, doc_title, doc_description, blocks, session_id=None\n):\n    \"\"\"Replace a resource file with a new one while keeping the same resource key.\"\"\"\n    import shutil\n\n    # Get or create session ID\n    if not session_id:\n        session_id = str(uuid.uuid4())\n\n    # Get session files directory\n    files_dir = session_manager.get_files_dir(session_id)\n\n    # Copy new file to session directory\n    new_file_name = os.path.basename(new_file_path)\n    session_file_path = files_dir / new_file_name\n    shutil.copy2(new_file_path, session_file_path)\n\n    # Update the resource and all blocks that use it\n    for resource in resources:\n        if resource.get(\"path\") == old_resource_path:\n            # Keep the same key and description, just update the path and name\n            resource[\"path\"] = str(session_file_path)\n            resource[\"name\"] = new_file_name\n            # Keep the existing title - don't update it\n            break\n\n    # Update all blocks that reference this resource\n    for block in blocks:\n        if \"resources\" in block:\n            for block_resource in block[\"resources\"]:\n                if block_resource.get(\"path\") == old_resource_path:\n                    block_resource[\"path\"] = str(session_file_path)\n                    block_resource[\"name\"] = new_file_name\n                    # Keep the existing title - don't update it\n\n    # Generate HTML for resources display\n    resources_html = generate_resource_html(resources)\n\n    # Regenerate outline with updated resources\n    json_str = generate_outline_json_from_state(doc_title, doc_description, resources, blocks)\n\n    # Return updated values including a success flag\n    return resources, blocks, gr.update(value=resources_html), json_str, \"Resource replaced successfully!\"\n\n\ndef load_example(example_id, session_id=None):\n    \"\"\"Load a predefined example based on the example ID.\"\"\"\n    if not example_id:\n        return (\n            gr.update(),\n            gr.update(),\n            gr.update(),\n            gr.update(),\n            gr.update(),\n            gr.update(),\n            gr.update(),\n            session_id,\n            gr.update(),\n            gr.update(),\n            gr.update(),\n        )\n\n    # Map example IDs to file paths - now using .docpack files\n    examples_dir = Path(__file__).parent.parent / \"examples\"\n    example_files = {\n        \"1\": examples_dir / \"readme-generation\" / \"readme.docpack\",\n        \"2\": examples_dir / \"launch-documentation\" / \"launch-documentation.docpack\",\n        \"3\": examples_dir\n        / \"scenario-4-annual-performance-review\"\n        / \"Annual Employee Performance Review_20250709_153352.docpack\",\n    }\n\n    file_path = example_files.get(example_id)\n    if not file_path or not file_path.exists():\n        # If docpack doesn't exist, show error message\n        error_msg = f\"Example file not found: {file_path.name if file_path else 'Unknown'}\"\n        return (\n            gr.update(),  # title\n            gr.update(),  # description\n            gr.update(),  # resources\n            gr.update(),  # blocks\n            gr.update(),  # outline\n            json.dumps({\"error\": error_msg}, indent=2),  # json_output\n            session_id,  # session_id\n        )\n\n    # Use the import_outline function to load the example\n    result = import_outline(str(file_path), session_id)\n    # import_outline now returns 11 values matching import_file.change outputs\n    # import_outline returns: title, desc, resources, blocks, outline, json, import_file, session_id, gen_html, gen_content, save_btn\n    # load_example needs: title, desc, resources, blocks, outline, json, session_id, gen_html, gen_content, save_btn\n    # We need to skip import_file (at index 6) from the result\n    return (\n        result[0],  # title\n        result[1],  # description\n        result[2],  # resources\n        result[3],  # blocks\n        result[4],  # outline\n        result[5],  # json_str\n        result[7],  # session_id (skip import_file at 6)\n        result[8],  # generated_content_html\n        result[9],  # generated_content\n        result[10],  # save_doc_btn\n    )\n\n\ndef import_outline(file_path, session_id=None):\n    \"\"\"Import an outline from a .docpack file and convert to blocks format.\"\"\"\n    if not file_path:\n        # Return 11 values matching import_file.change outputs\n        return (\n            gr.update(),  # title\n            gr.update(),  # description\n            gr.update(),  # resources\n            gr.update(),  # blocks\n            gr.update(),  # outline\n            gr.update(),  # json_output\n            None,  # import_file\n            session_id,  # gr_session_id\n            gr.update(),  # generated_content_html\n            gr.update(),  # generated_content\n            gr.update(),  # save_doc_btn\n        )\n\n    # Get or create session ID\n    if not session_id:\n        session_id = str(uuid.uuid4())\n\n    # Define allowed text file extensions\n    ALLOWED_EXTENSIONS = {\n        \".txt\",\n        \".md\",\n        \".py\",\n        \".c\",\n        \".cpp\",\n        \".h\",\n        \".java\",\n        \".js\",\n        \".ts\",\n        \".jsx\",\n        \".tsx\",\n        \".json\",\n        \".xml\",\n        \".yaml\",\n        \".yml\",\n        \".toml\",\n        \".ini\",\n        \".cfg\",\n        \".conf\",\n        \".sh\",\n        \".bash\",\n        \".zsh\",\n        \".fish\",\n        \".ps1\",\n        \".bat\",\n        \".cmd\",\n        \".rs\",\n        \".go\",\n        \".rb\",\n        \".php\",\n        \".pl\",\n        \".lua\",\n        \".r\",\n        \".m\",\n        \".swift\",\n        \".kt\",\n        \".scala\",\n        \".clj\",\n        \".ex\",\n        \".exs\",\n        \".elm\",\n        \".fs\",\n        \".ml\",\n        \".sql\",\n        \".html\",\n        \".htm\",\n        \".css\",\n        \".scss\",\n        \".sass\",\n        \".less\",\n        \".vue\",\n        \".svelte\",\n        \".astro\",\n        \".tex\",\n        \".rst\",\n        \".adoc\",\n        \".org\",\n        \".csv\",\n    }\n\n    try:\n        file_path = Path(file_path)\n\n        # Only accept .docpack files\n        if file_path.suffix.lower() != \".docpack\":\n            error_msg = \"Import failed: Only .docpack files are supported. Please use a .docpack file created by the Save function.\"\n            return (\n                gr.update(),  # title\n                gr.update(),  # description\n                gr.update(),  # resources\n                gr.update(),  # blocks\n                gr.update(),  # outline\n                json.dumps({\"error\": error_msg}, indent=2),  # json_output\n                None,  # import_file\n                session_id,  # session_id\n                gr.update(),  # generated_content_html\n                gr.update(),  # generated_content\n                gr.update(),  # save_doc_btn\n            )\n\n        # Use session directory for extraction\n        session_dir = session_manager.get_session_dir(session_id)\n\n        # Extract the docpack to session directory\n        json_data, extracted_files = DocpackHandler.extract_package(file_path, session_dir)\n\n        # Extract title and description\n        title = json_data.get(\"title\", \"\")\n        description = json_data.get(\"general_instruction\", \"\")\n\n        # Extract and validate resources\n        resources = []\n        invalid_resources = []\n        inline_resources = {}  # Store inline resources by key\n\n        for res_data in json_data.get(\"resources\", []):\n            resource_path = res_data.get(\"path\", \"\")\n            resource_name = Path(resource_path).name\n            file_ext = Path(resource_name).suffix.lower()\n\n            # Check if this is an inline resource\n            if res_data.get(\"is_inline\", False) or res_data.get(\"key\", \"\").startswith(\"inline_resource_\"):\n                # Store inline resource content for later use\n                inline_resources[res_data[\"key\"]] = resource_path\n                continue  # Don't add to regular resources\n\n            # Check if file extension is allowed\n            if file_ext not in ALLOWED_EXTENSIONS:\n                invalid_resources.append(f\"{resource_name} ({file_ext})\")\n                continue\n\n            resources.append({\n                \"key\": res_data.get(\"key\", \"\"),  # Preserve original key\n                \"path\": resource_path,\n                \"name\": resource_name,\n                \"title\": res_data.get(\"title\", resource_name),  # Preserve title or default to filename\n                \"type\": \"text\",  # All are text files now\n                \"description\": res_data.get(\"description\", \"\"),\n            })\n\n        # If there are invalid resources, show error and return\n        if invalid_resources:\n            error_msg = \"Import failed: The following resources have unsupported file types:\\n\" + \"\\n\".join(\n                invalid_resources\n            )\n            error_msg += f\"\\n\\nOnly text files are allowed: {', '.join(sorted(ALLOWED_EXTENSIONS))}\"\n            # Return error in the JSON output field\n            return (\n                gr.update(),  # title\n                gr.update(),  # description\n                gr.update(),  # resources\n                gr.update(),  # blocks\n                gr.update(),  # outline\n                json.dumps({\"error\": error_msg}, indent=2),  # json_output\n                None,  # import_file\n                session_id,  # session_id\n                gr.update(),  # generated_content_html\n                gr.update(),  # generated_content\n                gr.update(),  # save_doc_btn\n            )\n\n        # Convert sections to blocks\n        blocks = []\n\n        def sections_to_blocks(sections, parent_indent=-1):\n            \"\"\"Recursively convert sections to blocks.\"\"\"\n            for section in sections:\n                # Create a block from the section\n                block = {\n                    \"id\": str(uuid.uuid4()),\n                    \"heading\": section.get(\"title\", \"\"),\n                    \"content\": \"\",\n                    \"resources\": [],\n                    \"collapsed\": True,\n                    \"indent_level\": parent_indent + 1,\n                }\n\n                # Determine block type and content\n                if \"prompt\" in section:\n                    # AI block\n                    block[\"type\"] = \"ai\"\n                    block[\"content\"] = section.get(\"prompt\", \"\")\n                    block[\"ai_content\"] = section.get(\"prompt\", \"\")\n\n                    # Handle refs\n                    refs = section.get(\"refs\", [])\n                    if refs and resources:\n                        # Map refs back to resources by matching keys\n                        for ref in refs:\n                            # Find resource with matching key\n                            for resource in resources:\n                                if resource.get(\"key\") == ref:\n                                    block[\"resources\"].append(resource)\n                                    break\n\n                elif \"resource_key\" in section:\n                    # Text block\n                    block[\"type\"] = \"text\"\n                    block[\"text_content\"] = \"\"\n\n                    # Handle resource_key\n                    resource_key = section.get(\"resource_key\", \"\")\n\n                    # Check if this is an inline resource\n                    if resource_key in inline_resources:\n                        # Load content from inline resource file\n                        try:\n                            inline_path = inline_resources[resource_key]\n                            # If it's a relative path in a save directory, construct full path\n                            if not Path(inline_path).is_absolute():\n                                # Look for the file in the same directory as the imported JSON\n                                import_dir = Path(file_path).parent\n                                inline_path = import_dir / inline_path\n\n                            with open(inline_path, \"r\", encoding=\"utf-8\") as f:\n                                block[\"content\"] = f.read()\n                                block[\"text_content\"] = block[\"content\"]\n                                block[\"edited\"] = True  # Mark as edited\n                        except Exception as e:\n                            print(f\"Error loading inline resource: {e}\")\n                    elif resource_key and resources:\n                        # Regular resource reference - find by key\n                        for resource in resources:\n                            if resource.get(\"key\") == resource_key:\n                                block[\"resources\"].append(resource)\n                                # Auto-load content from the resource file\n                                try:\n                                    with open(resource[\"path\"], \"r\", encoding=\"utf-8\") as f:\n                                        block[\"content\"] = f.read()\n                                        block[\"text_content\"] = block[\"content\"]\n                                except Exception as e:\n                                    print(f\"Error loading resource content: {e}\")\n                                break\n                else:\n                    # Default to AI block if no specific type indicators\n                    block[\"type\"] = \"ai\"\n\n                blocks.append(block)\n\n                # Process nested sections\n                if \"sections\" in section:\n                    sections_to_blocks(section[\"sections\"], block[\"indent_level\"])\n\n        # Convert top-level sections\n        sections_to_blocks(json_data.get(\"sections\", []))\n\n        # If no blocks were created, add default ones\n        if not blocks:\n            blocks = [\n                {\n                    \"id\": str(uuid.uuid4()),\n                    \"type\": \"ai\",\n                    \"heading\": \"\",\n                    \"content\": \"\",\n                    \"resources\": [],\n                    \"collapsed\": False,\n                    \"indent_level\": 0,\n                }\n            ]\n        else:\n            # Ensure the first block is expanded\n            if blocks and len(blocks) > 0:\n                blocks[0][\"collapsed\"] = False\n\n        # Regenerate outline and JSON\n        json_str = generate_outline_json_from_state(title, description, resources, blocks)\n\n        # Generate resources HTML using the proper function\n        generate_resource_html(resources)\n\n        # Return values matching what import_file.change expects\n        return (\n            title,\n            description,\n            resources,\n            blocks,\n            json_str,\n            None,  # import_file (clear it)\n            session_id,\n            gr.update(\n                value=\"<em>Click '\u25b7 Generate' to see the generated content here.</em><br><br><br>\", visible=True\n            ),  # generated_content_html\n            gr.update(visible=False),  # generated_content\n            gr.update(interactive=False),  # save_doc_btn\n        )\n\n    except Exception as e:\n        error_msg = f\"Error importing file: {str(e)}\"\n        print(error_msg)\n        # Return current values on error matching expected outputs\n        return (\n            gr.update(),  # title\n            gr.update(),  # description\n            gr.update(),  # resources\n            gr.update(),  # blocks\n            gr.update(),  # outline\n            gr.update(),  # json_output\n            None,  # import_file\n            session_id,  # gr_session_id\n            gr.update(),  # generated_content_html\n            gr.update(),  # generated_content\n            gr.update(),  # save_doc_btn\n        )\n\n\ndef save_outline(title, outline_json, blocks):\n    \"\"\"Create a .docpack file with all resources bundled and return for download.\"\"\"\n    from datetime import datetime\n\n    try:\n        # Create filename from title and timestamp\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        docpack_name = f\"{timestamp}.docpack\"\n\n        # Create a temporary file for the docpack\n        temp_dir = Path(tempfile.gettempdir())\n        docpack_path = temp_dir / docpack_name\n\n        # Parse the current JSON\n        current_json = json.loads(outline_json)\n\n        # Collect all resource files and create key mapping\n        resource_files = []\n        resource_key_map = {}\n\n        for res in current_json.get(\"resources\", []):\n            resource_path = Path(res[\"path\"])\n            if resource_path.exists():\n                resource_files.append(resource_path)\n                resource_key_map[str(resource_path.resolve())] = res[\"key\"]\n\n        # Remove is_inline flags before saving\n        for res in current_json.get(\"resources\", []):\n            if \"is_inline\" in res:\n                del res[\"is_inline\"]\n\n        # Create the docpack with conflict-safe naming\n        DocpackHandler.create_package(\n            outline_data=current_json,\n            resource_files=resource_files,\n            output_path=docpack_path,\n            resource_key_map=resource_key_map,\n        )\n\n        # Return the file path for download\n        return gr.update(value=str(docpack_path), visible=True, interactive=True)\n\n    except Exception as e:\n        error_msg = f\"Error creating docpack: {str(e)}\"\n        print(error_msg)\n        return gr.update(value=None, visible=False)\n\n\ndef create_docpack_from_current_state():\n    \"\"\"Create a docpack using the current global document state.\"\"\"\n    import time\n    from datetime import datetime\n\n    global current_document_state\n\n    print(f\"=== CREATING DOCPACK at {datetime.now().isoformat()} ===\")\n    print(f\"Title: {current_document_state.get('title', 'N/A') if current_document_state else 'No state'}\")\n    print(f\"Has outline_json: {'outline_json' in current_document_state if current_document_state else False}\")\n    print(f\"Number of blocks: {len(current_document_state.get('blocks', [])) if current_document_state else 0}\")\n    print(f\"Full current_document_state: {current_document_state}\")\n\n    if not current_document_state:\n        print(\"ERROR: No current_document_state available for docpack creation\")\n        return None\n\n    try:\n        title = current_document_state.get(\"title\", \"Document\")\n        outline_json = current_document_state.get(\"outline_json\", \"{}\")\n        print(f\"DEBUG: Using title '{title}' for docpack filename\")\n\n        # Create filename from title and timestamp with milliseconds to ensure uniqueness\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        milliseconds = int(time.time() * 1000) % 1000\n        safe_title = \"\".join(c if c.isalnum() or c in \" -_\" else \"_\" for c in title)[:50]\n        docpack_name = f\"{safe_title}_{timestamp}_{milliseconds}.docpack\"\n        print(f\"DEBUG: Generated filename: {docpack_name} (from title: '{title}', timestamp: {timestamp})\")\n\n        # Create a temporary file for the docpack\n        temp_dir = Path(tempfile.gettempdir())\n        docpack_path = temp_dir / docpack_name\n\n        # Parse the current JSON\n        current_json = json.loads(outline_json)\n\n        # Collect all resource files and create key mapping\n        resource_files = []\n        resource_key_map = {}\n\n        for res in current_json.get(\"resources\", []):\n            resource_path = Path(res[\"path\"])\n            if resource_path.exists():\n                resource_files.append(resource_path)\n                resource_key_map[str(resource_path.resolve())] = res[\"key\"]\n\n        # Remove is_inline flags before saving\n        for res in current_json.get(\"resources\", []):\n            if \"is_inline\" in res:\n                del res[\"is_inline\"]\n\n        # Create the docpack with conflict-safe naming\n        DocpackHandler.create_package(\n            outline_data=current_json,\n            resource_files=resource_files,\n            output_path=docpack_path,\n            resource_key_map=resource_key_map,\n        )\n\n        # Return just the file path\n        return str(docpack_path)\n\n    except Exception as e:\n        error_msg = f\"Error creating docpack: {str(e)}\"\n        print(error_msg)\n        return None\n\n\ndef render_block_resources(block_resources, block_type, block_id):\n    \"\"\"Render the resources inside a block.\"\"\"\n    print(f\"render_block_resources for block {block_id}: {len(block_resources) if block_resources else 0} resources\")\n\n    if block_type == \"text\":\n        # Text blocks always show the drop zone, never show resources\n        return \"Drop reference files here to upload text.\"\n\n    # AI blocks show resources or drop zone\n    if not block_resources:\n        return \"Drop reference files here for AI context.\"\n\n    html = \"\"\n    for resource in block_resources:\n        # Use title if available, otherwise fall back to name\n        display_name = resource.get(\"title\", resource.get(\"name\", \"Unknown\"))\n        path = resource.get(\"path\", \"\").replace(\"'\", \"\\\\'\")  # Escape single quotes\n\n        # For AI blocks, show resource without description input and without icon\n        html += f\"\"\"\n        <div class=\"dropped-resource\" data-resource-path=\"{path}\">\n            <span class=\"dropped-resource-title\">{display_name}</span>\n            <span class=\"remove-resource\" onclick=\"removeBlockResource('{block_id}', '{path}')\">\u00d7</span>\n        </div>\n        \"\"\"\n\n    return html\n\n\ndef render_blocks(blocks, focused_block_id=None):\n    \"\"\"Render blocks as HTML.\"\"\"\n    import time\n\n    timestamp = int(time.time() * 1000)\n\n    print(f\"render_blocks called with {len(blocks) if blocks else 0} blocks at {timestamp}\")\n    if blocks:\n        for i, block in enumerate(blocks):\n            res_count = len(block.get(\"resources\", []))\n            print(f\"  Block {i} ({block['id']}): {res_count} resources\")\n\n    if not blocks:\n        return \"<div class='empty-blocks-message'>Click '+ Add AI' to add an AI generated section.</div><div class='empty-blocks-message'>Click '+ Add Text' to add a traditional text section.</div>\"\n\n    html = f\"<!-- Rendered at {timestamp} -->\\n\"\n    for i, block in enumerate(blocks):\n        block_id = block[\"id\"]\n        is_collapsed = block.get(\"collapsed\", False)\n        collapsed_class = \"collapsed\" if is_collapsed else \"\"\n        content_class = \"\" if is_collapsed else \"show\"\n\n        if block[\"type\"] == \"ai\":\n            heading_value = block.get(\"heading\", \"\")\n            indent_level = block.get(\"indent_level\", 0)\n\n            # Determine max allowed indent level based on previous block\n            max_allowed_indent = 0\n            if i > 0:\n                prev_block = blocks[i - 1]\n                prev_indent = prev_block.get(\"indent_level\", 0)\n                max_allowed_indent = prev_indent + 1\n\n            # Build indent controls - always include both buttons, just hide if not applicable\n            indent_controls = '<div class=\"indent-controls\">'\n            # Show indent button only if we can indent further\n            if indent_level < 5 and indent_level < max_allowed_indent:\n                indent_controls += (\n                    f\"<button class=\\\"indent-btn indent\\\" onclick=\\\"updateBlockIndent('{block_id}', 'in')\\\">\u21e5</button>\"\n                )\n            else:\n                indent_controls += '<div class=\"indent-btn-placeholder\"></div>'\n\n            if indent_level > 0:\n                indent_controls += f\"<button class=\\\"indent-btn outdent\\\" onclick=\\\"updateBlockIndent('{block_id}', 'out')\\\">\u21e4</button>\"\n            else:\n                indent_controls += '<div class=\"indent-btn-placeholder\"></div>'\n            indent_controls += \"</div>\"\n\n            html += f\"\"\"\n            <div class='content-block ai-block {collapsed_class}' data-id='{block_id}' data-indent='{indent_level}'>\n                {indent_controls}\n                <button class='collapse-btn' onclick='toggleBlockCollapse(\"{block_id}\")'>\n                    <span class='collapse-icon'>\u2335</span>\n                </button>\n                <button class='delete-btn' onclick='deleteBlock(\"{block_id}\")'>\ud83d\uddd1</button>\n                <button class='add-btn' onclick='addBlockAfter(\"{block_id}\")'>+</button>\n                <div class='block-header'>\n                    <input type='text' class='block-heading-inline' placeholder='Section Title'\n                           value='{heading_value}'\n                           onfocus='expandBlockOnHeadingFocus(\"{block_id}\"); setFocusedBlock(\"{block_id}\", true)'\n                           oninput='updateBlockHeading(\"{block_id}\", this.value)'/>\n                </div>\n                <div class='block-content {content_class}'>\n                    <div class='block-tabs'>\n                        <button class='block-tab active' onclick='focusBlockTextarea(\"{block_id}\")'>AI</button>\n                        <button class='block-tab' onclick='convertBlock(\"{block_id}\", \"text\")'>Text</button>\n                    </div>\n                    <textarea placeholder='Type your AI instruction here...\\nThis text will be used for AI content generation.'\n                              onfocus='setFocusedBlock(\"{block_id}\", true)'\n                              oninput='updateBlockContent(\"{block_id}\", this.value)'>{block[\"content\"]}</textarea>\n                    <div class='block-resources'>\n                        {render_block_resources(block.get(\"resources\", []), \"AI\", block_id)}\n                    </div>\n                </div>\n            </div>\n            \"\"\"\n        elif block[\"type\"] == \"heading\":\n            html += f\"\"\"\n            <div class='content-block heading-block' data-id='{block_id}'>\n                <button class='delete-btn' onclick='deleteBlock(\"{block_id}\")'>\ud83d\uddd1</button>\n                <button class='add-btn' onclick='addBlockAfter(\"{block_id}\")'>+</button>\n                <div class='block-header heading-header'>\n                    <input type='text' value='{block[\"content\"]}'\n                           oninput='updateBlockContent(\"{block_id}\", this.value)'/>\n                </div>\n            </div>\n            \"\"\"\n        elif block[\"type\"] == \"text\":\n            heading_value = block.get(\"heading\", \"\")\n            indent_level = block.get(\"indent_level\", 0)\n\n            # Determine max allowed indent level based on previous block\n            max_allowed_indent = 0\n            if i > 0:\n                prev_block = blocks[i - 1]\n                prev_indent = prev_block.get(\"indent_level\", 0)\n                max_allowed_indent = prev_indent + 1\n\n            # Build indent controls - always include both buttons, just hide if not applicable\n            indent_controls = '<div class=\"indent-controls\">'\n            # Show indent button only if we can indent further\n            if indent_level < 5 and indent_level < max_allowed_indent:\n                indent_controls += (\n                    f\"<button class=\\\"indent-btn indent\\\" onclick=\\\"updateBlockIndent('{block_id}', 'in')\\\">\u21e5</button>\"\n                )\n            else:\n                indent_controls += '<div class=\"indent-btn-placeholder\"></div>'\n\n            if indent_level > 0:\n                indent_controls += f\"<button class=\\\"indent-btn outdent\\\" onclick=\\\"updateBlockIndent('{block_id}', 'out')\\\">\u21e4</button>\"\n            else:\n                indent_controls += '<div class=\"indent-btn-placeholder\"></div>'\n            indent_controls += \"</div>\"\n\n            html += f\"\"\"\n            <div class='content-block text-block {collapsed_class}' data-id='{block_id}' data-indent='{indent_level}'>\n                {indent_controls}\n                <button class='collapse-btn' onclick='toggleBlockCollapse(\"{block_id}\")'>\n                    <span class='collapse-icon'>\u2335</span>\n                </button>\n                <button class='delete-btn' onclick='deleteBlock(\"{block_id}\")'>\ud83d\uddd1</button>\n                <button class='add-btn' onclick='addBlockAfter(\"{block_id}\")'>+</button>\n                <div class='block-header'>\n                    <input type='text' class='block-heading-inline' placeholder='Section Title'\n                           value='{heading_value}'\n                           onfocus='expandBlockOnHeadingFocus(\"{block_id}\"); setFocusedBlock(\"{block_id}\", true)'\n                           oninput='updateBlockHeading(\"{block_id}\", this.value)'/>\n                </div>\n                <div class='block-content {content_class}'>\n                    <div class='block-tabs'>\n                        <button class='block-tab' onclick='convertBlock(\"{block_id}\", \"ai\")'>AI</button>\n                        <button class='block-tab active' onclick='focusBlockTextarea(\"{block_id}\")'>Text</button>\n                    </div>\n                    <textarea placeholder='Type your text here...\\nThis text will be copied into your document.'\n                              onfocus='setFocusedBlock(\"{block_id}\", true)'\n                              oninput='updateBlockContent(\"{block_id}\", this.value)'>{block[\"content\"]}</textarea>\n                    <div class='block-resources'>\n                        {render_block_resources(block.get(\"resources\", []), \"text\", block_id)}\n                    </div>\n                </div>\n            </div>\n            \"\"\"\n\n    return html\n\n\ndef handle_ui_start_tab_file_upload(files, current_resources):\n    \"\"\"Handle file uploads on the Start tab.\"\"\"\n    if not files:\n        return current_resources, None, gr.update(visible=False)\n\n    # Add new files to resources\n    new_resources = current_resources.copy() if current_resources else []\n    warnings = []\n\n    for file_path in files:\n        if file_path:\n            file_name = os.path.basename(file_path)\n            file_size = os.path.getsize(file_path)\n\n            # Check if it's a docx file and if it's protected\n            if file_path.lower().endswith(\".docx\"):\n                is_protected, error_msg = check_docx_protected(file_path)\n                if is_protected:\n                    warnings.append(error_msg)\n                    continue  # Skip adding this file to resources\n\n            # Format file size\n            if file_size < 1024:\n                size_str = f\"{file_size} B\"\n            elif file_size < 1024 * 1024:\n                size_str = f\"{file_size / 1024:.1f} KB\"\n            else:\n                size_str = f\"{file_size / (1024 * 1024):.1f} MB\"\n\n            # Check if already in resources (by name)\n            if not any(r[\"name\"] == file_name for r in new_resources):\n                new_resources.append({\n                    \"path\": file_path,\n                    \"name\": file_name,\n                    \"size\": size_str,\n                    \"resource_type\": \"file\",  # Mark as file resource\n                })\n\n    # Create warning message if there were any protected files\n    if warnings:\n        import random\n\n        warning_id = f\"warning_{random.randint(1000, 9999)}\"\n        warning_html = f\"\"\"\n        <div id=\"{warning_id}\" style='position: relative; color: #dc2626; background: #fee2e2; padding: 8px 30px 8px 12px; border-radius: 4px; margin-top: 8px; font-size: 14px;'>\n            <button onclick=\"document.getElementById('{warning_id}').style.display='none'\" \n                    style='position: absolute; top: 4px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;' \n                    onmouseover=\"this.style.opacity='1'\" \n                    onmouseout=\"this.style.opacity='0.6'\"\n                    title='Close'>\u00d7</button>\n            {\"<br>\".join(warnings)}\n        </div>\n        \"\"\"\n        return new_resources, None, gr.update(value=warning_html, visible=True)\n\n    return new_resources, None, gr.update(visible=False)\n\n\ndef handle_start_draft_click_wrapper(prompt, resources, session_id=None):\n    \"\"\"Wrapper to handle the Draft button click synchronously.\"\"\"\n    print(\"DEBUG: handle_start_draft_click_wrapper called\")\n    print(f\"DEBUG: prompt type: {type(prompt)}, value: '{prompt}'\")\n    print(f\"DEBUG: resources type: {type(resources)}, value: {resources}\")\n    print(f\"DEBUG: session_id: {session_id}\")\n\n    # Run the async function synchronously\n\n    return asyncio.run(handle_start_draft_click(prompt, resources, session_id))\n\n\nasync def handle_start_draft_click(prompt, resources, session_id=None):\n    \"\"\"Handle the Draft button click on the Start tab.\"\"\"\n    print(\"DEBUG: In async handle_start_draft_click\")\n    print(f\"DEBUG: prompt value in async: '{prompt}'\")\n\n    if not prompt or not prompt.strip():\n        error_msg = \"Please enter a description of what you'd like to create.\"\n        print(f\"DEBUG: No prompt provided, returning error: {error_msg}\")\n        # Return 15 values to match outputs (added loading message and button)\n        return (\n            gr.update(),  # doc_title\n            gr.update(),  # doc_description\n            gr.update(),  # gr_references_state\n            gr.update(),  # gr_blocks_state\n            gr.update(),  # json_output\n            session_id,  # gr_session_id\n            gr.update(),  # generated_content_html\n            gr.update(),  # generated_content\n            gr.update(),  # save_doc_btn\n            gr.update(),  # switch_tab_trigger\n            gr.update(\n                value=f\"\"\"<div id=\"prompt_error\" style=\"position: relative; color: #dc2626; padding: 8px 30px 8px 12px; background: #fee2e2; border-radius: 4px; margin-top: 8px; font-size: 14px;\">\n                    <button onclick=\"document.getElementById('prompt_error').style.display='none'\" \n                            style=\"position: absolute; top: 4px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;\" \n                            onmouseover=\"this.style.opacity='1'\" \n                            onmouseout=\"this.style.opacity='0.6'\"\n                            title=\"Close\">\u00d7</button>\n                    {error_msg}\n                </div>\"\"\",\n                visible=True,\n            ),  # ui_start_tab_error_message\n            gr.update(),  # ui_start_tab_prompt_input - no change\n            gr.update(interactive=True),  # ui_start_tab_draft_btn\n        )\n\n    try:\n        # Get or create session ID\n        if not session_id:\n            session_id = str(uuid.uuid4())\n            print(f\"DEBUG: Created new session_id: {session_id}\")\n\n        print(f\"DEBUG: Calling generate_docpack_from_prompt with {len(resources) if resources else 0} resources\")\n\n        # Call the docpack generation function\n        docpack_path, outline_json = await generate_docpack_from_prompt(\n            prompt=prompt.strip(), resources=resources or [], session_id=session_id, dev_mode=IS_DEV_MODE\n        )\n\n        print(f\"DEBUG: Received docpack_path: {docpack_path}\")\n        print(f\"DEBUG: Received outline_json length: {len(outline_json) if outline_json else 0}\")\n\n        # Parse the outline JSON\n        if outline_json:\n            outline_data = json.loads(outline_json)\n            print(f\"DEBUG: Successfully parsed outline with title: {outline_data.get('title', 'No title')}\")\n\n            # Process the outline data similar to import_outline function\n            title = outline_data.get(\"title\", \"Untitled Document\")\n            description = outline_data.get(\"general_instruction\", \"\")\n\n            # Process resources - preserve metadata from original resources\n            processed_resources = []\n            session_files_dir = session_manager.get_files_dir(session_id)\n\n            # Create a lookup for original resource metadata by path\n            original_resources_by_path = {}\n            for orig_res in resources or []:\n                original_resources_by_path[orig_res.get(\"path\", \"\")] = orig_res\n\n            for res_data in outline_data.get(\"resources\", []):\n                resource_path = res_data.get(\"path\", \"\")\n                if resource_path:\n                    # Copy resource to session files directory if it exists\n                    source_path = Path(resource_path)\n                    if source_path.exists():\n                        target_path = session_files_dir / source_path.name\n                        if source_path != target_path:\n                            import shutil\n\n                            shutil.copy2(source_path, target_path)\n\n                        # Find original resource metadata\n                        original_resource = original_resources_by_path.get(resource_path, {})\n\n                        processed_resources.append({\n                            \"key\": res_data.get(\"key\", \"\"),\n                            \"name\": source_path.name,\n                            \"path\": str(target_path),\n                            \"description\": res_data.get(\"description\", \"\"),\n                            # Preserve original metadata, fallback to outline data, then defaults\n                            \"resource_type\": (\n                                original_resource.get(\"resource_type\") or res_data.get(\"resource_type\", \"file\")\n                            ),\n                            \"source_url\": (original_resource.get(\"source_url\") or res_data.get(\"source_url\")),\n                        })\n\n            # Convert sections to blocks\n            blocks = []\n\n            def sections_to_blocks(sections, parent_indent=-1):\n                \"\"\"Recursively convert sections to blocks.\"\"\"\n                for section in sections:\n                    block = {\n                        \"id\": str(uuid.uuid4()),\n                        \"heading\": section.get(\"title\", \"\"),\n                        \"content\": \"\",\n                        \"resources\": [],\n                        \"collapsed\": True,\n                        \"indent_level\": parent_indent + 1,\n                    }\n\n                    if \"prompt\" in section:\n                        # AI block\n                        block[\"type\"] = \"ai\"\n                        block[\"content\"] = section.get(\"prompt\", \"\")\n                        block[\"ai_content\"] = section.get(\"prompt\", \"\")\n\n                        # Handle refs\n                        refs = section.get(\"refs\", [])\n                        if refs and resources:\n                            for ref in refs:\n                                for resource in resources:\n                                    if resource.get(\"key\") == ref:\n                                        block[\"resources\"].append(resource)\n                                        break\n                    else:\n                        # Text block\n                        block[\"type\"] = \"text\"\n                        block[\"content\"] = \"\"\n\n                    blocks.append(block)\n\n                    # Process nested sections\n                    if \"sections\" in section and section[\"sections\"]:\n                        sections_to_blocks(section[\"sections\"], parent_indent=block[\"indent_level\"])\n\n            # Convert top-level sections\n            sections_to_blocks(outline_data.get(\"sections\", []))\n\n            # Ensure the first block is expanded (consistent with import behavior)\n            if blocks and len(blocks) > 0:\n                blocks[0][\"collapsed\"] = False\n\n            # Generate the JSON for the outline\n            json_str = json.dumps(outline_data, indent=2)\n\n            # Return all the values needed to populate the Draft+Generate tab\n            # This matches what import_outline returns\n            # DO NOT switch to the draft tab yet - that will happen in the next step\n            return (\n                title,  # doc_title\n                description,  # doc_description\n                processed_resources,  # gr_references_state\n                blocks,  # gr_blocks_state\n                json_str,  # json_output\n                session_id,  # gr_session_id\n                gr.update(visible=False),  # generated_content_html\n                gr.update(visible=False),  # generated_content\n                gr.update(interactive=False),  # save_doc_btn\n                gr.update(visible=True, value=f\"SWITCH_TO_DRAFT_TAB_{int(time.time() * 1000)}\"),  # switch_tab_trigger\n                gr.update(visible=False),  # ui_start_tab_error_message - hide on success\n                gr.update(\n                    lines=4, max_lines=10, interactive=True, elem_classes=\"start-prompt-input\"\n                ),  # ui_start_tab_prompt_input - preserve value but reset display properties\n                gr.update(interactive=True),  # ui_start_tab_draft_btn\n            )\n        else:\n            error_msg = \"Failed to generate outline. Please try again.\"\n            print(f\"DEBUG: No outline generated, returning error: {error_msg}\")\n            # Return 15 values to match outputs\n            return (\n                gr.update(),  # doc_title\n                gr.update(),  # doc_description\n                gr.update(),  # gr_references_state\n                gr.update(),  # gr_blocks_state\n                gr.update(),  # outline_state\n                gr.update(),  # json_output\n                session_id,  # gr_session_id\n                gr.update(),  # generated_content_html\n                gr.update(),  # generated_content\n                gr.update(),  # save_doc_btn\n                gr.update(),  # switch_tab_trigger\n                gr.update(\n                    value=f\"\"\"<div id=\"outline_error\" style=\"position: relative; color: #dc2626; padding: 8px 30px 8px 12px; background: #fee2e2; border-radius: 4px; margin-top: 8px; font-size: 14px;\">\n                        <button onclick=\"document.getElementById('outline_error').style.display='none'\" \n                                style=\"position: absolute; top: 4px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;\" \n                                onmouseover=\"this.style.opacity='1'\" \n                                onmouseout=\"this.style.opacity='0.6'\"\n                                title=\"Close\">\u00d7</button>\n                        {error_msg}\n                    </div>\"\"\",\n                    visible=True,\n                ),  # ui_start_tab_error_message\n                gr.update(lines=4, max_lines=10),  # ui_start_tab_prompt_input - preserve lines\n                gr.update(interactive=True),  # ui_start_tab_draft_btn\n            )\n\n    except Exception as e:\n        import traceback\n\n        error_msg = f\"Error: {str(e)}\"\n        print(f\"ERROR in handle_start_draft_click: {error_msg}\")\n        print(f\"Traceback: {traceback.format_exc()}\")\n        # Return 15 values to match outputs\n        return (\n            gr.update(),  # doc_title\n            gr.update(),  # doc_description\n            gr.update(),  # gr_references_state\n            gr.update(),  # gr_blocks_state\n            gr.update(),  # outline_state\n            gr.update(),  # json_output\n            session_id,  # gr_session_id\n            gr.update(),  # generated_content_html\n            gr.update(),  # generated_content\n            gr.update(),  # save_doc_btn\n            gr.update(),  # switch_tab_trigger\n            gr.update(\n                value=f\"\"\"<div id=\"exception_error\" style=\"position: relative; color: #dc2626; padding: 8px 30px 8px 12px; background: #fee2e2; border-radius: 4px; margin-top: 8px; font-size: 14px;\">\n                    <button onclick=\"document.getElementById('exception_error').style.display='none'\" \n                            style=\"position: absolute; top: 4px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;\" \n                            onmouseover=\"this.style.opacity='1'\" \n                            onmouseout=\"this.style.opacity='0.6'\"\n                            title=\"Close\">\u00d7</button>\n                    {error_msg}\n                </div>\"\"\",\n                visible=True,\n            ),  # ui_start_tab_error_message\n            gr.update(),  # ui_start_tab_prompt_input\n            gr.update(interactive=True),  # ui_start_tab_draft_btn\n        )\n\n\ndef handle_file_upload(files, current_resources, title, description, blocks, session_id=None):\n    \"\"\"Handle uploaded files and return HTML display of file names.\"\"\"\n    if not files:\n        # Don't return None for outline and json_output to avoid clearing them\n        # Don't hide warning on empty upload - keep existing warning visible\n        return current_resources, None, gr.update(), gr.update(), session_id, gr.update()\n\n    # Debug: Check what we're receiving\n    print(f\"DEBUG handle_file_upload - title: {title}, description: {description}, blocks: {blocks}\")\n\n    # Get or create session ID\n    if not session_id:\n        session_id = str(uuid.uuid4())\n\n    # Add new files to resources\n    new_resources = current_resources.copy() if current_resources else []\n    warnings = []\n\n    # Get session files directory\n    files_dir = session_manager.get_files_dir(session_id)\n\n    for file_path in files:\n        if file_path:\n            import shutil\n\n            file_name = os.path.basename(file_path)\n\n            # Check if it's a docx file and if it's protected\n            if file_path.lower().endswith(\".docx\"):\n                is_protected, error_msg = check_docx_protected(file_path)\n                if is_protected:\n                    warnings.append(error_msg)\n                    continue  # Skip adding this file to resources\n\n            # Copy file to session directory\n            session_file_path = files_dir / file_name\n            shutil.copy2(file_path, session_file_path)\n\n            # Check if already in resources (by name)\n            if not any(r[\"name\"] == file_name for r in new_resources):\n                # All uploaded files are text files now\n                new_resources.append({\n                    \"path\": str(session_file_path),\n                    \"name\": file_name,\n                    \"title\": file_name,  # Default title is the filename\n                    \"type\": \"text\",\n                    \"description\": \"\",  # Initialize with empty description\n                    \"resource_type\": \"file\",  # Mark as file resource\n                })\n\n    # Regenerate outline with new resources\n    json_str = generate_outline_json_from_state(title, description, new_resources, blocks)\n\n    # Debug: Check what we're returning\n    print(f\"DEBUG handle_file_upload - returning json_str: {json_str[:100]}...\")\n    print(\"DEBUG handle_file_upload - full return values:\")\n    print(f\"  - new_resources length: {len(new_resources)}\")\n    print(\"  - file_upload clear: None\")\n    print(f\"  - json_str type: {type(json_str)}, length: {len(json_str)}\")\n    print(f\"  - session_id: {session_id}\")\n\n    # Create warning message if there were any protected files\n    if warnings:\n        import random\n\n        warning_id = f\"warning_{random.randint(1000, 9999)}\"\n        warning_html = f\"\"\"\n        <div id=\"{warning_id}\" style='position: relative; color: #dc2626; background: #fee2e2; padding: 10px 30px 10px 12px; border-radius: 4px; margin: 10px 0;'>\n            <button onclick=\"document.getElementById('{warning_id}').style.display='none'\" \n                    style='position: absolute; top: 5px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;' \n                    onmouseover=\"this.style.opacity='1'\" \n                    onmouseout=\"this.style.opacity='0.6'\"\n                    title='Close'>\u00d7</button>\n            {\"<br>\".join(warnings)}\n            <br><small style='color: #991b1b; margin-top: 5px; display: block;'>Protected files were not added to resources.</small>\n        </div>\n        \"\"\"\n        warning_update = gr.update(value=warning_html, visible=True)\n    else:\n        warning_update = gr.update(visible=False)\n\n    return (\n        new_resources,\n        None,  # Clear file upload\n        json_str,\n        session_id,\n        warning_update,\n    )\n\n\n# Global variable to store current document state for download\ncurrent_document_state = {\"title\": \"\", \"outline_json\": \"{}\", \"blocks\": []}\n\n\ndef update_resource_title_gradio(resources, resource_path, new_title, title, description, blocks):\n    \"\"\"Update resource title from Gradio component.\"\"\"\n    for resource in resources:\n        if resource[\"path\"] == resource_path:\n            resource[\"title\"] = new_title\n            break\n\n    # Update title in all blocks that have this resource\n    for block in blocks:\n        if \"resources\" in block:\n            for res in block[\"resources\"]:\n                if res.get(\"path\") == resource_path:\n                    res[\"title\"] = new_title\n\n    # Regenerate outline\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return resources, json_str\n\n\ndef update_resource_description_gradio(resources, resource_path, new_description, title, description, blocks):\n    \"\"\"Update resource description from Gradio component.\"\"\"\n    for resource in resources:\n        if resource[\"path\"] == resource_path:\n            resource[\"description\"] = new_description\n            break\n\n    # Update description in ALL blocks that have this resource\n    for block in blocks:\n        if \"resources\" in block:\n            for res in block[\"resources\"]:\n                if res.get(\"path\") == resource_path:\n                    res[\"description\"] = new_description\n\n    # Regenerate outline\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return resources, json_str\n\n\ndef delete_resource_gradio(resources, resource_path, title, description, blocks):\n    \"\"\"Delete a resource from Gradio component.\"\"\"\n    print(f\"Deleting resource: {resource_path}\")\n\n    # Remove from resources list\n    new_resources = [res for res in resources if res.get(\"path\") != resource_path]\n\n    # Also remove from all blocks that have this resource\n    updated_blocks = []\n    for block in blocks:\n        block_copy = block.copy()\n        if \"resources\" in block_copy:\n            # Remove the resource with matching path\n            original_count = len(block_copy[\"resources\"])\n            block_copy[\"resources\"] = [res for res in block_copy[\"resources\"] if res.get(\"path\") != resource_path]\n            new_count = len(block_copy[\"resources\"])\n\n            if original_count != new_count:\n                print(f\"Removed resource from block {block_copy['id']}: {original_count} -> {new_count}\")\n\n            # If this is a text block and we just removed its resource, clear the content\n            if block_copy[\"type\"] == \"text\" and len(block_copy[\"resources\"]) == 0:\n                block_copy[\"content\"] = \"\"\n\n        updated_blocks.append(block_copy)\n\n    # Regenerate outline\n    json_str = generate_outline_json_from_state(title, description, new_resources, updated_blocks)\n    # Return blocks too so the UI updates\n    return new_resources, updated_blocks, json_str\n\n\ndef replace_resource_file_gradio(resources, old_resource_path, new_file, title, description, blocks, session_id=None):\n    \"\"\"Replace a resource file from Gradio component.\"\"\"\n    if not new_file:\n        return resources, None, \"{}\", None, gr.update(visible=False)\n\n    try:\n        # Check if the new file is a protected docx\n        if new_file.name.lower().endswith(\".docx\"):\n            is_protected, error_msg = check_docx_protected(new_file.name)\n            if is_protected:\n                import random\n\n                warning_id = f\"warning_{random.randint(1000, 9999)}\"\n                warning_html = f\"\"\"\n                <div id=\"{warning_id}\" style='position: relative; color: #dc2626; background: #fee2e2; padding: 8px 25px 8px 8px; border-radius: 4px; margin: 5px 0; font-size: 13px;'>\n                    <button onclick=\"document.getElementById('{warning_id}').style.display='none'\" \n                            style='position: absolute; top: 2px; right: 2px; background: none; border: none; color: #dc2626; font-size: 16px; cursor: pointer; padding: 0 3px; line-height: 1; opacity: 0.6;' \n                            onmouseover=\"this.style.opacity='1'\" \n                            onmouseout=\"this.style.opacity='0.6'\"\n                            title='Close'>\u00d7</button>\n                    <strong>\u26a0\ufe0f Cannot Replace:</strong><br>{error_msg}\n                </div>\n                \"\"\"\n                return resources, None, \"{}\", None, gr.update(value=warning_html, visible=True)\n\n        # Get or create session\n        if not session_id:\n            session_id = str(uuid.uuid4())\n\n        session_dir = session_manager.get_session_dir(session_id)\n\n        # Copy new file to session directory\n        new_file_path = Path(new_file.name)\n        new_filename = new_file_path.name\n        dest_path = session_dir / new_filename\n\n        # If the new file has the same name as an existing file, add a suffix\n        counter = 1\n        while dest_path.exists() and str(dest_path) != old_resource_path:\n            stem = new_file_path.stem\n            suffix = new_file_path.suffix\n            new_filename = f\"{stem}_{counter}{suffix}\"\n            dest_path = session_dir / new_filename\n            counter += 1\n\n        # Copy the file\n        import shutil\n\n        shutil.copy2(new_file.name, dest_path)\n\n        # Update resources list\n        for i, resource in enumerate(resources):\n            if resource[\"path\"] == old_resource_path:\n                # Keep the same title and description\n                old_title = resource.get(\"title\", \"\")\n                old_description = resource.get(\"description\", \"\")\n\n                # Update the resource\n                resources[i] = {\n                    \"name\": new_filename,\n                    \"path\": str(dest_path),\n                    \"title\": old_title if old_title else new_filename,\n                    \"description\": old_description,\n                }\n\n                # Update in all blocks\n                for block in blocks:\n                    if \"resources\" in block:\n                        for j, res in enumerate(block[\"resources\"]):\n                            if res.get(\"path\") == old_resource_path:\n                                block[\"resources\"][j] = {\n                                    \"path\": str(dest_path),\n                                    \"title\": old_title if old_title else new_filename,\n                                    \"description\": old_description,\n                                }\n\n                                # If it's a text block, reload the content\n                                if block[\"type\"] == \"text\":\n                                    try:\n                                        if dest_path.lower().endswith(\".docx\"):\n                                            # Extract text from docx file\n                                            block[\"content\"] = docx_to_text(dest_path)\n                                        else:\n                                            # Read as regular text file\n                                            with open(dest_path, \"r\", encoding=\"utf-8\") as f:\n                                                block[\"content\"] = f.read()\n                                    except Exception as e:\n                                        print(f\"Error loading new file content: {e}\")\n\n                break\n\n        # Regenerate outline\n        json_str = generate_outline_json_from_state(title, description, resources, blocks)\n\n        # Return with cleared file input and no warning\n        return resources, json_str, None, gr.update(visible=False)\n\n    except Exception as e:\n        print(f\"Error replacing resource file: {e}\")\n        import random\n\n        warning_id = f\"warning_{random.randint(1000, 9999)}\"\n        # Check if it's a protection error\n        if \"protected or encrypted\" in str(e):\n            warning_html = f\"\"\"\n            <div id=\"{warning_id}\" style='position: relative; color: #dc2626; background: #fee2e2; padding: 8px 25px 8px 8px; border-radius: 4px; margin: 5px 0; font-size: 13px;'>\n                <button onclick=\"document.getElementById('{warning_id}').style.display='none'\" \n                        style='position: absolute; top: 2px; right: 2px; background: none; border: none; color: #dc2626; font-size: 16px; cursor: pointer; padding: 0 3px; line-height: 1; opacity: 0.6;' \n                        onmouseover=\"this.style.opacity='1'\" \n                        onmouseout=\"this.style.opacity='0.6'\"\n                        title='Close'>\u00d7</button>\n                <strong>\u26a0\ufe0f Replace Failed:</strong><br>{str(e)}\n            </div>\n            \"\"\"\n            return resources, None, \"{}\", None, gr.update(value=warning_html, visible=True)\n        # For other errors, show a generic error message\n        warning_html = f\"\"\"\n        <div id=\"{warning_id}\" style='position: relative; color: #92400e; background: #fef3c7; padding: 8px 25px 8px 8px; border-radius: 4px; margin: 5px 0; font-size: 13px;'>\n            <button onclick=\"document.getElementById('{warning_id}').style.display='none'\" \n                    style='position: absolute; top: 2px; right: 2px; background: none; border: none; color: #92400e; font-size: 16px; cursor: pointer; padding: 0 3px; line-height: 1; opacity: 0.6;' \n                    onmouseover=\"this.style.opacity='1'\" \n                    onmouseout=\"this.style.opacity='0.6'\"\n                    title='Close'>\u00d7</button>\n            <strong>\u26a0\ufe0f Error:</strong><br>Failed to replace file: {str(e)}\n        </div>\n        \"\"\"\n        return resources, None, \"{}\", None, gr.update(value=warning_html, visible=True)\n\n\ndef handle_refresh_start_url_resource(resource_index, resources):\n    \"\"\"Handle refresh URL resource request from Start tab and re-render.\"\"\"\n    print(f\"DEBUG: Refreshing URL resource at index {resource_index}\")\n\n    # Call the refresh function\n    updated_resources, error_msg = refresh_url_resource(resource_index, resources)\n\n    # Re-render the resources display\n    resources_html = render_start_resources(updated_resources)\n\n    if error_msg:\n        # Show error message if refresh failed\n        import random\n\n        warning_id = f\"warning_{random.randint(1000, 9999)}\"\n        warning_html = f\"\"\"\n        <div id=\"{warning_id}\" style='position: relative; color: #dc2626; background: #fee2e2; padding: 8px 30px 8px 12px; border-radius: 4px; margin-top: 8px; font-size: 14px;'>\n            <button onclick=\"document.getElementById('{warning_id}').style.display='none'\" \n                    style='position: absolute; top: 4px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;' \n                    onmouseover='this.style.opacity=\"1\"' onmouseout='this.style.opacity=\"0.6\"'>\u00d7</button>\n            {error_msg}\n        </div>\n        \"\"\"\n        return updated_resources, resources_html, gr.update(value=warning_html, visible=True)\n    else:\n        # Clear any existing error messages\n        return updated_resources, resources_html, gr.update(visible=False)\n\n\ndef refresh_url_resource(resource_index, resources):\n    \"\"\"Refresh a URL resource by re-downloading its content.\"\"\"\n    if not resources or resource_index >= len(resources):\n        return resources, None\n\n    resource = resources[resource_index]\n\n    # Only refresh URL resources\n    if resource.get(\"resource_type\") != \"url\" or not resource.get(\"source_url\"):\n        return resources, \"Error: This is not a URL resource\"\n\n    try:\n        # Re-download content from the URL\n        url = resource[\"source_url\"]\n        content = extract_text_from_url(url)\n\n        # Write updated content to the same file path\n        with open(resource[\"path\"], \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n\n        # Update file size\n        file_size = os.path.getsize(resource[\"path\"])\n        if file_size < 1024:\n            size_str = f\"{file_size} B\"\n        elif file_size < 1024 * 1024:\n            size_str = f\"{file_size / 1024:.1f} KB\"\n        else:\n            size_str = f\"{file_size / (1024 * 1024):.1f} MB\"\n\n        # Update the resource info\n        resources[resource_index][\"size\"] = size_str\n\n        return resources, None  # Success, no error\n\n    except Exception as e:\n        error_msg = f\"Failed to refresh URL content: {str(e)}\"\n        return resources, error_msg\n\n\ndef render_start_resources(resources):\n    print(f\"DEBUG render_start_resources called with {len(resources) if resources else 0} resources\")\n    if resources and len(resources) > 0:\n        # Create a flex container for resources\n        html_content = '<div class=\"start-resources-list\">'\n        for idx, resource in enumerate(resources):\n            print(f\"  Rendering resource: {resource['name']}\")\n\n            # Check if this is a URL resource based on resource_type or legacy url field\n            is_url_resource = resource.get(\"resource_type\") == \"url\" or \"url\" in resource\n            resource_icon = \"\ud83c\udf10\" if is_url_resource else \"\ud83d\udcc4\"\n            resource_class = \"url-resource\" if is_url_resource else \"file-resource\"\n\n            # Create tooltip text\n            if is_url_resource:\n                source_url = resource.get(\"source_url\") or resource.get(\"url\", \"\")\n                tooltip_text = f\"Downloaded from: {source_url}\"\n            else:\n                tooltip_text = f\"File: {resource['name']}\"\n\n            # Create different templates for URL vs file resources\n            # File resource template with delete button only\n            html_content += f\"\"\"\n                <div class=\"dropped-resource {resource_class}\" title=\"{tooltip_text}\">\n                    <span class=\"resource-icon\">{resource_icon}</span>\n                    <span class=\"resource-name\">{resource[\"name\"]}</span>\n                    <span class=\"resource-size\">{resource.get(\"size\", \"\")}</span>\n                    <button class=\"remove-resource\" onclick=\"event.stopPropagation(); removeStartResourceByIndex({idx}, '{resource[\"name\"]}'); return false;\">\ud83d\uddd1</button>\n                </div>\n            \"\"\"\n        html_content += \"</div>\"\n        return html_content\n    else:\n        # Return empty div when no resources\n        return '<div class=\"start-resources-list\"></div>'\n\n\ndef delete_gradio_and_render(resources, path, title, desc, blocks, focused):\n    \"\"\"Delete resource via Gradio button and render blocks.\"\"\"\n    print(\"\\n=== delete_gradio_and_render called ===\")\n    new_res, new_blocks, outline, json_str = delete_resource_gradio(resources, path, title, desc, blocks)\n    blocks_html = render_blocks(new_blocks, focused)\n    print(\"=== delete_gradio_and_render complete ===\\n\")\n    return new_res, new_blocks, outline, json_str, blocks_html\n\n\ndef handle_add_ai_block_top(blocks, _, title, description, resources):\n    blocks = add_ai_block(blocks, None)\n    json_str = generate_outline_json_from_state(title, description, resources, blocks)\n    return blocks, json_str\n\n\ndef update_collapse_button_state(blocks):\n    \"\"\"Update the collapse/expand button to reflect current block states.\"\"\"\n    # Check if any block is expanded (collapsed = False)\n    any_expanded = any(not block.get(\"collapsed\", False) for block in blocks if block)\n\n    if any_expanded:\n        # Some sections open - show up pointing (rotated -90deg)\n        return gr.update(value=\"\u00bb\", elem_classes=\"workspace-collapse-btn collapse-mode\")\n    else:\n        # All sections closed - show down pointing (rotated 90deg)\n        return gr.update(value=\"\u00bb\", elem_classes=\"workspace-collapse-btn\")\n\n\ndef toggle_all_blocks(blocks):\n    \"\"\"Toggle between expand all and collapse all based on current state.\n    If ANY block is expanded, collapse all. If ALL are collapsed, expand all.\"\"\"\n    # Check if any block is expanded (collapsed = False)\n    any_expanded = any(not block.get(\"collapsed\", False) for block in blocks if block)\n\n    # If any block is expanded, collapse all; otherwise expand all\n    for block in blocks:\n        block[\"collapsed\"] = any_expanded\n\n    # Update button to reflect NEW state after toggle\n    # After toggling: if we collapsed all (any_expanded was True), now all are collapsed\n    # After toggling: if we expanded all (any_expanded was False), now some are expanded\n    new_state_all_collapsed = any_expanded  # If any were expanded, we collapsed them all\n\n    if new_state_all_collapsed:\n        # All sections now closed - show down chevron (normal)\n        elem_classes = \"workspace-collapse-btn\"\n    else:\n        # Some sections now open - show up chevron (rotated)\n        elem_classes = \"workspace-collapse-btn collapse-mode\"\n\n    # Always use double angle quote, rotation is handled by CSS\n    return blocks, gr.update(value=\"\u00bb\", elem_classes=elem_classes)\n\n\ndef delete_and_render(resources, resource_path, title, description, blocks, focused_id):\n    \"\"\"Delete resource and return both the state updates and rendered HTML.\"\"\"\n    print(\"\\n=== delete_and_render called ===\")\n    print(f\"Resource path: {resource_path}\")\n    print(f\"Blocks before: {len(blocks)} blocks\")\n\n    new_resources, updated_blocks, outline, json_str = delete_resource_from_panel(\n        resources, resource_path, title, description, blocks\n    )\n\n    print(f\"Blocks after delete: {len(updated_blocks)} blocks\")\n\n    # Render the blocks immediately\n    blocks_html = render_blocks(updated_blocks, focused_id)\n\n    print(f\"Generated HTML length: {len(blocks_html)}\")\n    print(\"=== delete_and_render complete ===\\n\")\n\n    return new_resources, updated_blocks, outline, json_str, blocks_html\n\n\nasync def handle_generate_and_update_download(title, description, resources, blocks, session_id):\n    \"\"\"Generate document and update download button.\"\"\"\n    json_str, content, docx_path, markdown_path = await handle_document_generation(\n        title, description, resources, blocks, session_id\n    )\n\n    # Hide HTML component and show Markdown component\n    html_update = gr.update(visible=False)\n    markdown_update = gr.update(value=content, visible=True)\n\n    if docx_path:\n        # Keep the DOCX path as default for the hidden download button\n        download_update = gr.update(value=docx_path)\n        # Enable the display button\n        display_btn_update = gr.update(interactive=True)\n    else:\n        download_update = gr.update()\n        display_btn_update = gr.update(interactive=False)\n\n    # Re-enable the generate button\n    generate_btn_update = gr.update(interactive=True)\n\n    print(f\"DEBUG: Returning DOCX path to state: {docx_path}\")\n    print(f\"DEBUG: Returning Markdown path to state: {markdown_path}\")\n\n    # Return both file paths for state storage\n    return (\n        json_str,\n        markdown_update,\n        html_update,\n        download_update,\n        display_btn_update,\n        generate_btn_update,\n        docx_path,\n        markdown_path,\n    )\n\n\ndef handle_download_format(format_type, docx_path, markdown_path):\n    \"\"\"Handle download based on selected format.\"\"\"\n    print(f\"Download format selected: {format_type}\")\n    print(f\"DOCX path: {docx_path}\")\n    print(f\"Markdown path: {markdown_path}\")\n\n    if format_type == \"markdown\" and markdown_path:\n        print(f\"Setting download to markdown: {markdown_path}\")\n        # Return the markdown file path for download\n        return gr.update(value=markdown_path)\n    elif format_type == \"docx\" and docx_path:\n        print(f\"Setting download to DOCX: {docx_path}\")\n        # Return the DOCX file path for download\n        return gr.update(value=docx_path)\n    else:\n        print(\"No valid format or path, keeping current state\")\n        # Keep current state\n        return gr.update()\n\n\ndef handle_resource_replacement(resources, old_path, new_file, doc_title, doc_description, blocks, session_id):\n    \"\"\"Handle resource file replacement.\"\"\"\n    if not new_file:\n        # No file selected, return unchanged - regenerate outline to return current state\n        json_str = generate_outline_json_from_state(doc_title, doc_description, resources, blocks)\n        return resources, blocks, json_str, \"\"\n\n    # new_file is the file path from Gradio\n    new_file_path = new_file if isinstance(new_file, str) else new_file.name\n\n    # Call the replace function\n    updated_resources, updated_blocks, resources_html, json_str, success_msg = replace_resource_file(\n        resources, old_path, new_file_path, doc_title, doc_description, blocks, session_id\n    )\n\n    # Return only the values that match the outputs list\n    return updated_resources, updated_blocks, json_str, success_msg\n\n\ndef check_prompt_before_submit(prompt):\n    \"\"\"Check if prompt exists and show error if not.\"\"\"\n    if not prompt or not prompt.strip():\n        # Show error message, hide loading, enable button\n        return (\n            gr.update(\n                value=\"\"\"<div id=\"prompt_error\" style=\"position: relative; color: #dc2626; padding: 8px 30px 8px 12px; background: #fee2e2; border-radius: 4px; margin-top: 8px; font-size: 14px;\">\n                    <button onclick=\"document.getElementById('prompt_error').style.display='none'\" \n                            style=\"position: absolute; top: 4px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;\" \n                            onmouseover=\"this.style.opacity='1'\" \n                            onmouseout=\"this.style.opacity='0.6'\"\n                            title=\"Close\">\u00d7</button>\n                    Please enter a description of what you'd like to create.\n                </div>\"\"\",\n                visible=True,\n            ),\n            gr.update(interactive=True),  # Enable button\n        )\n    else:\n        # Hide error message, show loading, disable button\n        return (\n            gr.update(visible=False),\n            gr.update(interactive=True),  # Keep button enabled\n        )\n\n\ndef handle_ui_start_tab_file_upload_with_render(files, current_resources):\n    \"\"\"Handle file uploads and render the resources.\"\"\"\n    new_resources, clear_upload, warning_update = handle_ui_start_tab_file_upload(files, current_resources)\n    resources_html = render_start_resources(new_resources)\n    return new_resources, clear_upload, resources_html, warning_update\n\n\ndef handle_ui_start_tab_url_submit(urls_input, current_resources):\n    \"\"\"Handle URL submissions on the Start tab.\"\"\"\n    if not urls_input or not urls_input.strip():\n        return current_resources, \"\", gr.update(visible=False)\n\n    # Create temp directory for downloads\n    import tempfile\n\n    temp_dir = tempfile.mkdtemp()\n\n    try:\n        # Download URLs to temp directory\n        url_resources = download_urls_to_temp(urls_input, temp_dir)\n\n        # Add URL resources to current resources\n        new_resources = current_resources.copy() if current_resources else []\n        new_resources.extend(url_resources)\n\n        # Clear the URL input and return success\n        return new_resources, \"\", gr.update(visible=False)\n\n    except Exception as e:\n        # Return error message\n        import random\n\n        warning_id = f\"warning_{random.randint(1000, 9999)}\"\n        error_html = f\"\"\"\n        <div id=\"{warning_id}\" style='position: relative; color: #dc2626; background: #fee2e2; padding: 8px 30px 8px 12px; border-radius: 4px; margin-top: 8px; font-size: 14px;'>\n            <button onclick=\"document.getElementById('{warning_id}').style.display='none'\" \n                    style='position: absolute; top: 4px; right: 5px; background: none; border: none; color: #dc2626; font-size: 18px; cursor: pointer; padding: 0 5px; opacity: 0.6;' \n                    onmouseover=\"this.style.opacity='1'\" \n                    onmouseout=\"this.style.opacity='0.6'\"\n                    title='Close'>\u00d7</button>\n            <strong>URL Download Error:</strong><br>{str(e)}\n        </div>\n        \"\"\"\n        return current_resources, urls_input, gr.update(value=error_html, visible=True)\n\n\ndef handle_ui_start_tab_url_submit_with_render(urls_input, current_resources):\n    \"\"\"Handle URL submissions and render the resources.\"\"\"\n    new_resources, cleared_input, warning_update = handle_ui_start_tab_url_submit(urls_input, current_resources)\n    resources_html = render_start_resources(new_resources)\n    return new_resources, cleared_input, resources_html, warning_update\n\n\ndef extract_resources_from_docpack(docpack_path, session_id=None):\n    \"\"\"Extract resources from a docpack file.\"\"\"\n    # Define allowed extensions for start tab (same as file upload)\n    ALLOWED_EXTENSIONS = {\n        \".txt\",\n        \".md\",\n        \".py\",\n        \".c\",\n        \".cpp\",\n        \".h\",\n        \".java\",\n        \".js\",\n        \".ts\",\n        \".jsx\",\n        \".tsx\",\n        \".json\",\n        \".xml\",\n        \".yaml\",\n        \".yml\",\n        \".toml\",\n        \".ini\",\n        \".cfg\",\n        \".conf\",\n        \".sh\",\n        \".bash\",\n        \".zsh\",\n        \".fish\",\n        \".ps1\",\n        \".bat\",\n        \".cmd\",\n        \".rs\",\n        \".go\",\n        \".rb\",\n        \".php\",\n        \".pl\",\n        \".lua\",\n        \".r\",\n        \".m\",\n        \".swift\",\n        \".kt\",\n        \".scala\",\n        \".clj\",\n        \".ex\",\n        \".erl\",\n        \".hs\",\n        \".ml\",\n        \".fs\",\n        \".nim\",\n        \".d\",\n        \".dart\",\n        \".jl\",\n        \".v\",\n        \".zig\",\n        \".html\",\n        \".htm\",\n        \".css\",\n        \".scss\",\n        \".sass\",\n        \".less\",\n        \".vue\",\n        \".svelte\",\n        \".astro\",\n        \".tex\",\n        \".rst\",\n        \".adoc\",\n        \".org\",\n        \".csv\",\n    }\n\n    resources = []\n    if docpack_path.exists():\n        print(f\"DEBUG: Docpack exists at {docpack_path}\")\n        try:\n            # Use provided session ID or create a new one\n            if not session_id:\n                session_id = str(uuid.uuid4())\n                print(f\"DEBUG: Created new session ID: {session_id}\")\n            else:\n                print(f\"DEBUG: Using existing session ID: {session_id}\")\n\n            # Create a temporary directory for extraction\n            with tempfile.TemporaryDirectory() as temp_dir:\n                print(f\"DEBUG: Created temp directory: {temp_dir}\")\n                # Extract the docpack - convert temp_dir to Path object\n                print(f\"DEBUG: Extracting docpack from {docpack_path} to {temp_dir}\")\n                json_data, extracted_files = DocpackHandler.extract_package(str(docpack_path), Path(temp_dir))\n                print(f\"DEBUG: Extraction successful. Found {len(extracted_files)} files\")\n                print(f\"DEBUG: JSON data has {len(json_data.get('resources', []))} resources\")\n\n                # Process resources from the docpack\n                for res_data in json_data.get(\"resources\", []):\n                    # Skip inline resources\n                    if res_data.get(\"is_inline\", False) or res_data.get(\"key\", \"\").startswith(\"inline_resource_\"):\n                        continue\n\n                    # Get the actual file from extracted files\n                    resource_filename = Path(res_data.get(\"path\", \"\")).name\n                    file_ext = Path(resource_filename).suffix.lower()\n\n                    # Check if file extension is allowed\n                    if file_ext not in ALLOWED_EXTENSIONS:\n                        continue\n\n                    for extracted_file in extracted_files:\n                        if Path(extracted_file).name == resource_filename:\n                            # Read the file content\n                            with open(extracted_file, \"r\", encoding=\"utf-8\") as f:\n                                content = f.read()\n\n                            # Use the session ID created at the beginning\n                            session_dir = session_manager.get_session_dir(session_id)\n\n                            # Convert Path to string for os.path operations\n                            session_dir_str = str(session_dir)\n\n                            # Save the file to session directory\n                            files_dir = os.path.join(session_dir_str, \"files\")\n                            os.makedirs(files_dir, exist_ok=True)\n                            target_path = os.path.join(files_dir, resource_filename)\n                            with open(target_path, \"w\", encoding=\"utf-8\") as f:\n                                f.write(content)\n\n                            # Calculate file size\n                            file_size = len(content.encode(\"utf-8\"))\n                            if file_size < 1024:\n                                size_str = f\"{file_size} B\"\n                            elif file_size < 1024 * 1024:\n                                size_str = f\"{file_size / 1024:.1f} KB\"\n                            else:\n                                size_str = f\"{file_size / (1024 * 1024):.1f} MB\"\n\n                            # Use the same format as handle_ui_start_tab_file_upload\n                            resources.append({\n                                \"path\": target_path,\n                                \"name\": resource_filename,\n                                \"size\": size_str,\n                            })\n                            break\n        except Exception as e:\n            print(f\"Error extracting resources from docpack: {e}\")\n\n    print(f\"DEBUG extract_resources_from_docpack: Returning {len(resources)} resources\")\n    for r in resources:\n        print(f\"  Resource: {r}\")\n    return resources\n\n\ndef load_code_readme_example(session_id):\n    \"\"\"Load the code README example prompt and resources.\"\"\"\n    # Get or create session\n    if not session_id:\n        session_id = str(uuid.uuid4())\n\n    prompt = \"Generate a comprehensive production-ready README for the target codebase. Include key features, installation instructions, usage examples, API documentation, an architecture overview, and contribution guidelines. IMPORTANT to use ONLY the facts available in the referenced documents (code, configs, docs, tests, etc.). Keep prose short, use bullet lists when helpful, and prefer plan language over marketing fluff.  Assumer the audience is a developer seeing the project for the first time.\"\n\n    # Extract resources from the README docpack\n    examples_dir = Path(__file__).parent.parent / \"examples\"\n    docpack_path = examples_dir / \"readme-generation\" / \"readme.docpack\"\n    resources = extract_resources_from_docpack(docpack_path, session_id)\n\n    print(f\"DEBUG: Loaded {len(resources)} resources for README example\")\n    for r in resources:\n        print(f\"  - {r['name']} ({r['size']})\")\n\n    # Render the resources HTML\n    resources_html = render_start_resources(resources)\n\n    return prompt, resources, session_id, resources_html\n\n\ndef load_product_launch_example(session_id):\n    \"\"\"Load the product launch example prompt and resources.\"\"\"\n    # Get or create session\n    if not session_id:\n        session_id = str(uuid.uuid4())\n\n    prompt = \"Create a comprehensive product launch documentation package for a new B2B SaaS analytics product.  Include the value proposition, implementation details and customer benefits.  There should be a product over section, one on technical architecture, an implementation guide, pricing and packaging, and go-to market strategy.  Other areas to consider include an announcement blog post, press release, internal team briefing, and customer FAQ.  Be sure to use clear, professional language appropriate for both technical and business stakeholders.\"\n\n    # Extract resources from the product launch docpack\n    examples_dir = Path(__file__).parent.parent / \"examples\"\n    docpack_path = examples_dir / \"launch-documentation\" / \"launch-documentation.docpack\"\n    resources = extract_resources_from_docpack(docpack_path, session_id)\n\n    # Render the resources HTML\n    resources_html = render_start_resources(resources)\n\n    return prompt, resources, session_id, resources_html\n\n\ndef load_performance_review_example(session_id):\n    \"\"\"Load the performance review example prompt and resources.\"\"\"\n    # Get or create session\n    if not session_id:\n        session_id = str(uuid.uuid4())\n\n    prompt = \"Generate an annual performance review for an employee. It will be used by both the manager and the employee to discuss the employee's progress.  Include key achievements, areas for growth, training and development and next years goals.  Make sure there is an employee overview as well.  Make it constructive and motivating, but also concise.  Folks are busy.\"\n\n    # Extract resources from the performance review docpack\n    examples_dir = Path(__file__).parent.parent / \"examples\"\n    docpack_path = (\n        examples_dir\n        / \"scenario-4-annual-performance-review\"\n        / \"Annual Employee Performance Review_20250709_153352.docpack\"\n    )\n    resources = extract_resources_from_docpack(docpack_path, session_id)\n\n    # Render the resources HTML\n    resources_html = render_start_resources(resources)\n\n    return prompt, resources, session_id, resources_html\n\n\ndef remove_start_resource(resources, index_str, name):\n    \"\"\"Remove a resource from the Start tab by index.\"\"\"\n    print(\n        f\"DEBUG: remove_start_resource called with resources={len(resources) if resources else 0}, index_str='{index_str}', name='{name}'\"\n    )\n\n    if not resources or not index_str:\n        print(\"DEBUG: Early return - no resources or no index_str\")\n        resources_html = render_start_resources(resources)\n        return resources, resources_html\n\n    try:\n        index = int(index_str)\n        print(f\"DEBUG: Parsed index={index}, resources length={len(resources)}\")\n\n        if 0 <= index < len(resources):\n            print(f\"DEBUG: Index is valid. Resource at index: {resources[index].get('name', 'unknown')}\")\n\n            # Verify the name matches as a safety check\n            if resources[index][\"name\"] == name:\n                print(f\"DEBUG: Name matches, removing resource at index {index}\")\n                new_resources = resources.copy()\n                removed_resource = new_resources.pop(index)\n                print(f\"DEBUG: Removed resource: {removed_resource}\")\n                resources_html = render_start_resources(new_resources)\n                print(f\"DEBUG: Successfully removed resource, new count: {len(new_resources)}\")\n                return new_resources, resources_html\n            else:\n                print(f\"DEBUG: Name mismatch - expected '{name}', got '{resources[index]['name']}'\")\n        else:\n            print(f\"DEBUG: Index {index} out of range for {len(resources)} resources\")\n    except (ValueError, IndexError) as e:\n        print(f\"DEBUG: Exception in remove_start_resource: {e}\")\n\n    print(\"DEBUG: No changes made, returning original resources\")\n    resources_html = render_start_resources(resources)\n    return resources, resources_html\n\n\ndef create_app():\n    \"\"\"Create and return the Document Builder Gradio app.\"\"\"\n\n    # Load custom CSS\n    css_path = Path(__file__).parent / \"static\" / \"css\" / \"styles.css\"\n    with open(css_path, \"r\") as f:\n        custom_css = f.read()\n\n    # Load custom JavaScript\n    js_path = Path(__file__).parent / \"static\" / \"js\" / \"script.js\"\n    with open(js_path, \"r\") as f:\n        js_content = f.read()\n\n    # Wrap JS in script tags for head injection\n    custom_js = f\"<script>{js_content}</script>\"\n\n    with gr.Blocks(title=\"Document Generator\", css=custom_css, head=custom_js) as app:\n        # Needed to declare up front, so elements will appear in deployed DOM\n        gr.DownloadButton(visible=True, elem_classes=\"hidden-component\")\n        gr.File(visible=True, elem_classes=\"hidden-component\")\n        gr.Textbox(visible=True, elem_classes=\"hidden-component\")\n        gr.TextArea(visible=True, elem_classes=\"hidden-component\")\n        gr.Code(visible=True, elem_classes=\"hidden-component\")\n\n        initial_blocks = [\n            {\n                \"id\": str(uuid.uuid4()),\n                \"type\": \"ai\",\n                \"heading\": \"\",\n                \"content\": \"\",\n                \"attached_references\": [],\n                \"collapsed\": False,  # AI block starts expanded\n                \"indent_level\": 0,\n            },\n            {\n                \"id\": str(uuid.uuid4()),\n                \"type\": \"text\",\n                \"heading\": \"\",\n                \"content\": \"\",\n                \"attached_references\": [],\n                \"collapsed\": True,  # Text block starts collapsed\n                \"indent_level\": 0,\n            },\n        ]\n\n        gr_start_attached_references_state = gr.State([])\n        gr_references_state = gr.State([])\n        gr_focused_block_state = gr.State(None)\n        gr_blocks_state = gr.State(initial_blocks)\n        gr_session_id = gr.State(None)\n        initial_json = generate_outline_json_from_state(\"\", \"\", [], initial_blocks)\n\n        # Main app layout\n        with gr.Tab(\"Draft\", id=\"start_tab\"):\n            with gr.Column(elem_classes=\"start-tab-container\"):\n                # Big centered welcome message\n                gr.Markdown(\"# Welcome to Document Generator\", elem_classes=\"start-welcome-title\")\n                gr.Markdown(\"Draft once. Regenerate forever.\", elem_classes=\"start-welcome-subtitle\")\n\n                # Single expanding card\n                with gr.Column(elem_classes=\"start-input-card-container\"):\n                    with gr.Column(elem_classes=\"start-input-card\"):\n                        gr.TextArea(\n                            label=\"What document would you like to create?\",\n                            elem_classes=\"resource-drop-label\",\n                        )\n                        # Example buttons container - always visible at the top\n                        with gr.Column(elem_classes=\"start-examples-container\"):\n                            with gr.Row(elem_classes=\"start-examples-buttons\"):\n                                ui_start_tab_example_code_readme_btn = gr.Button(\n                                    \"\ud83d\udcdd Code README\", variant=\"secondary\", size=\"sm\", elem_classes=\"start-example-btn\"\n                                )\n                                ui_start_tab_example_product_launch_btn = gr.Button(\n                                    \"\ud83d\ude80 Product Launch\",\n                                    variant=\"secondary\",\n                                    size=\"sm\",\n                                    elem_classes=\"start-example-btn\",\n                                )\n                                ui_start_tab_example_performance_review_btn = gr.Button(\n                                    \"\ud83d\udcc8 Performance Review\",\n                                    variant=\"secondary\",\n                                    size=\"sm\",\n                                    elem_classes=\"start-example-btn\",\n                                )\n\n                        # User prompt input\n                        ui_start_tab_prompt_input = gr.TextArea(\n                            placeholder=\"Describe your structured document here...\\n\",\n                            show_label=False,\n                            elem_classes=\"start-prompt-input\",\n                            lines=4,\n                            max_lines=10,\n                            elem_id=\"start-prompt-input\",\n                            value=\"\",  # Explicitly set initial value\n                        )\n\n                        # Error message component (hidden by default)\n                        ui_start_tab_error_message = gr.HTML(\n                            value=\"\", visible=False, elem_classes=\"start-error-message\"\n                        )\n\n                        # Expandable content within the same card\n                        with gr.Column(elem_classes=\"start-expandable-content\", elem_id=\"start-expandable-section\"):\n                            # Display uploaded references (above dropzone and button)\n                            with gr.Column(elem_classes=\"start-resources-display-container\"):\n                                # Create a placeholder for the references display\n                                ui_start_tab_attached_references_display = gr.HTML(\n                                    value='<div class=\"start-resources-list\"></div>',\n                                    elem_classes=\"start-resources-display\",\n                                )\n\n                            # Upload area - full width\n                            gr.TextArea(\n                                label=\"Add reference files for AI context. (.docx, .md, .csv, .py, .json, .txt, etc.)\",\n                                elem_classes=\"resource-drop-label\",\n                            )\n                            # File upload dropzone\n                            ui_start_tab_file_upload = gr.File(\n                                file_count=\"multiple\",\n                                file_types=SUPPORTED_FILE_TYPES,\n                                elem_classes=\"start-file-upload-dropzone\",\n                                show_label=False,\n                                height=90,\n                            )\n\n                            # Warning message for protected files\n                            ui_start_tab_upload_warning = gr.HTML(visible=False)\n\n                            # URL input section\n                            with gr.Row(elem_classes=\"start-url-input-row\"):\n                                ui_start_tab_url_input = gr.Textbox(\n                                    placeholder=\"Enter web URLs (comma separated): https://example.com, https://docs.example.com\",\n                                    show_label=False,\n                                    elem_classes=\"start-url-input\",\n                                    scale=4,\n                                    lines=1,\n                                )\n                                ui_start_tab_url_submit_btn = gr.Button(\n                                    \"Add URLs\",\n                                    variant=\"secondary\",\n                                    size=\"sm\",\n                                    elem_classes=\"start-url-submit-btn\",\n                                    scale=1,\n                                )\n\n                            # URL warning message\n                            ui_start_tab_url_warning = gr.HTML(visible=False)\n\n                            # Draft button - full width below dropzone\n                            ui_start_tab_draft_btn = gr.Button(\n                                \"Draft\",\n                                variant=\"primary\",\n                                size=\"sm\",\n                                elem_classes=\"start-get-started-btn start-draft-btn\",\n                                elem_id=\"start-get-started-btn\",\n                            )\n\n                # Main feature card with three examples\n                with gr.Column(elem_classes=\"start-feature-card\"):\n                    gr.Markdown(\"### Why Choose Document Generator?\", elem_classes=\"start-feature-title\")\n                    gr.Markdown(\n                        \"Build living document templates you control. Fine-tune sections, lock in what works, regenerate what needs updating. Perfect for content that evolves with your codebase, grows with new resources, or needs to stay current automatically.\",\n                        elem_classes=\"start-feature-description\",\n                    )\n\n                    # Three feature columns\n                    with gr.Row(elem_classes=\"start-features-grid\"):\n                        with gr.Column(scale=1, elem_classes=\"start-feature-item\"):\n                            template_img_path = (\n                                Path(__file__).parent / \"static\" / \"images\" / \"template_control-removebg-preview.jpg\"\n                            )\n                            gr.Image(\n                                value=str(template_img_path),\n                                show_label=False,\n                                height=150,\n                                container=False,\n                                elem_classes=\"start-feature-image\",\n                                elem_id=\"template-control-image\",\n                                show_download_button=False,\n                                show_fullscreen_button=False,\n                                interactive=False,\n                            )\n                            gr.Markdown(\"### Template Control\", elem_classes=\"start-feature-item-title\")\n                            gr.Markdown(\n                                \"Get started fast, then own the template. Update sections, adjust prompts, fine-tune your design. Maintain exactly the structure you need.\",\n                                elem_classes=\"start-feature-item-text\",\n                            )\n\n                        with gr.Column(scale=1, elem_classes=\"start-feature-item\"):\n                            evergreen_img_path = (\n                                Path(__file__).parent / \"static\" / \"images\" / \"evergreen_content-removebg-preview.jpg\"\n                            )\n                            gr.Image(\n                                value=str(evergreen_img_path),\n                                show_label=False,\n                                height=150,\n                                container=False,\n                                elem_classes=\"start-feature-image\",\n                                elem_id=\"evergreen-content-image\",\n                                show_download_button=False,\n                                show_fullscreen_button=False,\n                                interactive=False,\n                            )\n                            gr.Markdown(\"### Evergreen Content\", elem_classes=\"start-feature-item-title\")\n                            gr.Markdown(\n                                \"Link to evolving resources - code, docs, notes. Regenerate anytime to pull in the latest context. Perfect for READMEs, API docs, or any content that tracks changing information.\",\n                                elem_classes=\"start-feature-item-text\",\n                            )\n\n                        with gr.Column(scale=1, elem_classes=\"start-feature-item\"):\n                            smart_img_path = (\n                                Path(__file__).parent / \"static\" / \"images\" / \"smart_regeneration-removebg-preview.jpg\"\n                            )\n                            gr.Image(\n                                value=str(smart_img_path),\n                                show_label=False,\n                                height=150,\n                                container=False,\n                                elem_classes=\"start-feature-image\",\n                                elem_id=\"smart-regeneration-image\",\n                                show_download_button=False,\n                                show_fullscreen_button=False,\n                                interactive=False,\n                            )\n                            gr.Markdown(\"### Smart Regeneration\", elem_classes=\"start-feature-item-title\")\n                            gr.Markdown(\n                                \"Refresh while keeping refined content intact. Regenerate specific parts with new data - your polished introduction stays perfect while metrics update automatically.\",\n                                elem_classes=\"start-feature-item-text\",\n                            )\n\n                # Process section\n                with gr.Column(elem_classes=\"start-process-section\"):\n                    gr.Markdown(\"## How It Works\", elem_classes=\"start-process-title\")\n                    gr.Markdown(\n                        \"Three simple steps to transform your ideas into polished documents\",\n                        elem_classes=\"start-process-subtitle\",\n                    )\n\n                    with gr.Row(elem_classes=\"start-process-container\"):\n                        # Left side - Steps\n                        with gr.Column(scale=1, elem_classes=\"start-process-steps-vertical\"):\n                            # Step 1\n                            with gr.Row(elem_classes=\"start-process-step-vertical start-step-1\"):\n                                with gr.Column(scale=0, min_width=60, elem_classes=\"start-step-number-col\"):\n                                    gr.Markdown(\"1\", elem_classes=\"start-step-number-vertical\")\n                                with gr.Column(scale=1, elem_classes=\"start-step-content\"):\n                                    gr.Markdown(\"### Draft Your Template\", elem_classes=\"start-step-title\")\n                                    gr.Markdown(\n                                        \"Start with AI assistance to create your initial document structure. Describe what you need and upload reference materials.\",\n                                        elem_classes=\"start-step-description\",\n                                    )\n\n                            # Step 2\n                            with gr.Row(elem_classes=\"start-process-step-vertical start-step-2\"):\n                                with gr.Column(scale=0, min_width=60, elem_classes=\"start-step-number-col\"):\n                                    gr.Markdown(\"2\", elem_classes=\"start-step-number-vertical\")\n                                with gr.Column(scale=1, elem_classes=\"start-step-content\"):\n                                    gr.Markdown(\"### Edit & Update\", elem_classes=\"start-step-title\")\n                                    gr.Markdown(\n                                        \"Refine your outline and keep resources current. Update reference files as content changes, adjust prompts, and reorganize sections to match your evolving needs.\",\n                                        elem_classes=\"start-step-description\",\n                                    )\n\n                            # Step 3\n                            with gr.Row(elem_classes=\"start-process-step-vertical start-step-3\"):\n                                with gr.Column(scale=0, min_width=60, elem_classes=\"start-step-number-col\"):\n                                    gr.Markdown(\"3\", elem_classes=\"start-step-number-vertical\")\n                                with gr.Column(scale=1, elem_classes=\"start-step-content\"):\n                                    gr.Markdown(\"### Generate & Export\", elem_classes=\"start-step-title\")\n                                    gr.Markdown(\n                                        \"Click generate to create your final document. Export in multiple formats and regenerate anytime with updated content.\",\n                                        elem_classes=\"start-step-description\",\n                                    )\n\n                        # Right side - Visual placeholder\n                        with gr.Column(scale=1, elem_classes=\"start-process-visual\"):\n                            gr.HTML(\n                                \"\"\"\n                                <div class=\"process-visual-placeholder\">\n                                    <div class=\"visual-content\">\n                                        <svg viewBox=\"0 0 400 300\" xmlns=\"http://www.w3.org/2000/svg\">\n                                            <!-- Document icon -->\n                                            <rect x=\"100\" y=\"50\" width=\"200\" height=\"250\" rx=\"8\" fill=\"#f0f9f9\" stroke=\"#4a9d9e\" stroke-width=\"2\"/>\n\n                                            <!-- Lines representing text -->\n                                            <rect x=\"120\" y=\"80\" width=\"160\" height=\"8\" rx=\"4\" fill=\"#4a9d9e\" opacity=\"0.3\"/>\n                                            <rect x=\"120\" y=\"100\" width=\"140\" height=\"8\" rx=\"4\" fill=\"#4a9d9e\" opacity=\"0.3\"/>\n                                            <rect x=\"120\" y=\"120\" width=\"150\" height=\"8\" rx=\"4\" fill=\"#4a9d9e\" opacity=\"0.3\"/>\n\n                                            <!-- AI sparkle -->\n                                            <g transform=\"translate(250, 70)\">\n                                                <path d=\"M0,-10 L3,-3 L10,0 L3,3 L0,10 L-3,3 L-10,0 L-3,-3 Z\" fill=\"#4a9d9e\" opacity=\"0.8\"/>\n                                            </g>\n\n                                            <!-- Sections -->\n                                            <rect x=\"120\" y=\"150\" width=\"160\" height=\"40\" rx=\"4\" fill=\"#e8f5f5\" stroke=\"#4a9d9e\" stroke-width=\"1\"/>\n                                            <rect x=\"120\" y=\"200\" width=\"160\" height=\"40\" rx=\"4\" fill=\"#e8f5f5\" stroke=\"#4a9d9e\" stroke-width=\"1\"/>\n                                            <rect x=\"120\" y=\"250\" width=\"160\" height=\"40\" rx=\"4\" fill=\"#e8f5f5\" stroke=\"#4a9d9e\" stroke-width=\"1\"/>\n                                        </svg>\n                                        <p class=\"visual-caption\">Your document takes shape with AI assistance</p>\n                                    </div>\n                                </div>\n                            \"\"\",\n                                elem_classes=\"start-process-visual-content\",\n                            )\n\n        # Second tab - Existing Document Builder content\n        with gr.Tab(\"Update + Generate\", id=\"document_builder_tab\"):\n            with gr.Row():\n                # App name and explanation\n                with gr.Column(elem_classes=\"app-header-col\"):\n                    gr.Markdown(\"# Document Generator\")\n                    gr.Markdown(\" An AI tool for creating structured documents with customizable sections.\")\n\n                # Import and Save buttons\n                with gr.Column():\n                    with gr.Row(elem_classes=\"header-buttons-row\"):\n                        # Add empty space to push buttons to the right\n                        gr.HTML(\"<div class='button-spacer' style='flex: 1;'></div>\")\n                        # Try Examples button with dropdown container\n                        with gr.Column(elem_classes=\"try-examples-container\"):\n                            gr.Button(\n                                \"Template Examples\",\n                                elem_id=\"try-examples-btn-id\",\n                                variant=\"secondary\",\n                                size=\"sm\",\n                                elem_classes=\"try-examples-btn\",\n                            )\n                            # Dropdown menu (hidden by default via CSS)\n                            with gr.Column(elem_classes=\"examples-dropdown\", elem_id=\"examples-dropdown-id\"):\n                                gr.HTML(\"\"\"\n                                    <div class=\"examples-dropdown-item\" data-example=\"1\">\n                                        <div class=\"example-title\">README</div>\n                                        <div class=\"example-desc\">Technical documentation with code</div>\n                                    </div>\n                                    <div class=\"examples-dropdown-item\" data-example=\"2\">\n                                        <div class=\"example-title\">Product Launch Documentation</div>\n                                        <div class=\"example-desc\">Product research and strategy</div>\n                                    </div>\n                                    <div class=\"examples-dropdown-item\" data-example=\"3\">\n                                        <div class=\"example-title\">Annual Performance Review</div>\n                                        <div class=\"example-desc\">Employee evaluation and feedback</div>\n                                    </div>\n                                \"\"\")\n                        # New button (for resetting document)\n                        new_doc_btn = gr.Button(\n                            \"New\",\n                            elem_id=\"new-builder-btn-id\",\n                            variant=\"secondary\",\n                            size=\"sm\",\n                            elem_classes=\"new-builder-btn\",\n                        )\n                        gr.Button(\n                            \"Import\",\n                            elem_id=\"import-builder-btn-id\",\n                            variant=\"secondary\",\n                            size=\"sm\",\n                            elem_classes=\"import-builder-btn\",\n                        )\n                        save_outline_btn = gr.DownloadButton(\n                            \"Save\",\n                            elem_id=\"save-builder-btn-id\",\n                            variant=\"secondary\",\n                            size=\"sm\",\n                            elem_classes=\"save-builder-btn\",\n                            visible=True,\n                            value=create_docpack_from_current_state,\n                        )\n\n                    import_file = gr.File(\n                        label=\"Import Docpack\",\n                        file_types=[\".docpack\"],\n                        visible=True,\n                        elem_id=\"import-file-input\",\n                        elem_classes=\"hidden-component\",\n                    )\n\n            # Document title and description\n            with gr.Row(elem_classes=\"header-section\"):\n                # Document title (narrower width)\n                doc_title = gr.Textbox(\n                    value=\"\",\n                    placeholder=\"Document Title\",\n                    label=None,\n                    show_label=False,\n                    elem_id=\"doc-title-id\",\n                    elem_classes=\"doc-title-box\",\n                    scale=2,\n                    interactive=True,\n                    lines=1,\n                    max_lines=1,\n                    visible=True,\n                )\n\n                # Document description (wider width)\n                doc_description = gr.TextArea(\n                    value=\"\",\n                    placeholder=\"Provide overall guidance for the document generation.\\nSpecifics may include purpose, audience, style, format, etc.\",\n                    label=None,\n                    show_label=False,\n                    elem_id=\"doc-description-id\",\n                    elem_classes=\"doc-description-box\",\n                    scale=5,\n                    lines=2,\n                    max_lines=10,\n                    interactive=True,\n                    visible=True,\n                )\n\n            # Main content area with three columns\n            with gr.Row():\n                # Resources column: Upload Resources button\n                with gr.Column(scale=1, elem_classes=\"resources-col\"):\n                    # Drag and drop file upload component\n                    file_upload = gr.File(\n                        file_count=\"multiple\",\n                        file_types=SUPPORTED_FILE_TYPES,\n                        elem_classes=\"file-upload-dropzone\",\n                        visible=True,\n                        height=90,\n                        show_label=False,\n                    )\n\n                    # Warning message for protected files - placed before the render area\n                    file_upload_warning = gr.HTML(visible=False, elem_classes=\"file-upload-warning\")\n\n                    # Container for dynamic resource components\n                    with gr.Column(elem_classes=\"resources-display-area\"):\n\n                        @gr.render(inputs=gr_references_state)\n                        def render_resource_components(resources):\n                            if not resources:\n                                gr.HTML(\n                                    value=\"<p style='color: #666; font-size: 12px'>(.docx, .md, .csv, .py, .json, .txt, etc.)</p>\"\n                                    \"<p style='color: #666; font-size: 12px'>These reference files will be used for AI context.</p>\"\n                                )\n                            else:\n                                for idx, resource in enumerate(resources):\n                                    # Check if this is a URL resource\n                                    is_url_resource = resource.get(\"resource_type\") == \"url\" or \"url\" in resource\n                                    print(\"resource type: \", resource.get(\"resource_type\"))\n                                    source_url = resource.get(\"source_url\") or resource.get(\"url\", \"\")\n\n                                    with gr.Group(elem_classes=\"resource-item-gradio\"):\n                                        # Hidden element containing resource path for drag and drop\n                                        gr.HTML(\n                                            f'<div class=\"resource-path-hidden\" style=\"display:none;\" data-path=\"{resource[\"path\"]}\">{resource[\"path\"]}</div>'\n                                        )\n\n                                        with gr.Row(elem_classes=\"resource-row-gradio\"):\n                                            with gr.Column(scale=1, elem_classes=\"resource-info-col\"):\n                                                # Resource title\n                                                resource_title = gr.Textbox(\n                                                    value=resource.get(\"title\", resource[\"name\"]),\n                                                    placeholder=\"Title\",\n                                                    label=None,\n                                                    show_label=False,\n                                                    elem_classes=\"resource-title-gradio\",\n                                                    scale=1,\n                                                )\n\n                                                # Show different button combinations based on resource type\n                                                with gr.Row():\n                                                    if is_url_resource:\n                                                        # URL resource: refresh button + delete button\n                                                        refresh_btn = gr.Button(\n                                                            \"\ud83d\udd04\",\n                                                            elem_classes=\"resource-refresh-btn\",\n                                                            size=\"sm\",\n                                                        )\n                                                    delete_btn = gr.Button(\n                                                        \"\ud83d\uddd1\", elem_classes=\"resource-delete-btn\", size=\"sm\"\n                                                    )\n\n                                                # Resource description\n                                                resource_desc = gr.Textbox(\n                                                    value=resource.get(\"description\", \"\"),\n                                                    placeholder=\"Add a description for this resource...\",\n                                                    label=None,\n                                                    show_label=False,\n                                                    elem_classes=\"resource-desc-gradio\",\n                                                    lines=2,\n                                                    scale=1,\n                                                )\n\n                                                # Filename display with different icons and tooltips\n                                                if is_url_resource:\n                                                    filename_html = f'<div title=\"{source_url}\">\ud83c\udf10 {resource[\"name\"]} (from URL)</div>'\n                                                else:\n                                                    filename_html = f\"<div>\ud83d\udcc4 {resource['name']}</div>\"\n\n                                                gr.HTML(\n                                                    elem_classes=\"resource-filename\",\n                                                    value=filename_html,\n                                                )\n\n                                        # Connect events for this resource\n                                        resource_path = resource[\"path\"]\n\n                                        # Show different replacement areas based on resource type\n                                        if not is_url_resource:\n                                            # File resource: show file upload area\n                                            replace_file = gr.File(\n                                                label=\"Drop file here to replace\",\n                                                file_types=SUPPORTED_FILE_TYPES,\n                                                elem_classes=\"resource-upload-gradio\",\n                                                scale=1,\n                                                show_label=False,\n                                            )\n\n                                            # File replacement event handler\n                                            replace_file.upload(\n                                                fn=replace_resource_file_gradio,\n                                                inputs=[\n                                                    gr_references_state,\n                                                    gr.State(resource_path),\n                                                    replace_file,\n                                                    doc_title,\n                                                    doc_description,\n                                                    gr_blocks_state,\n                                                    gr_session_id,\n                                                ],\n                                                outputs=[\n                                                    gr_references_state,\n                                                    json_output,\n                                                    replace_file,\n                                                    replace_warning,\n                                                ],\n                                            ).then(\n                                                # Force JSON update after resources render\n                                                fn=lambda title, desc, res, blocks: generate_outline_json_from_state(\n                                                    title, desc, res, blocks\n                                                ),\n                                                inputs=[\n                                                    doc_title,\n                                                    doc_description,\n                                                    gr_references_state,\n                                                    gr_blocks_state,\n                                                ],\n                                                outputs=[json_output],\n                                            )\n\n                                        # Warning message for protected files\n                                        replace_warning = gr.HTML(visible=False)\n\n                                        # Title update - don't update gr_references_state to avoid re-render\n                                        resource_title.change(\n                                            fn=update_resource_title_gradio,\n                                            inputs=[\n                                                gr_references_state,\n                                                gr.State(resource_path),\n                                                resource_title,\n                                                doc_title,\n                                                doc_description,\n                                                gr_blocks_state,\n                                            ],\n                                            outputs=[\n                                                gr.State(),\n                                                json_output,\n                                            ],  # Use dummy State to avoid re-render\n                                            trigger_mode=\"always_last\",  # Only trigger after user stops typing\n                                        )\n\n                                        # Description update - don't update gr_references_state to avoid re-render\n                                        resource_desc.change(\n                                            fn=update_resource_description_gradio,\n                                            inputs=[\n                                                gr_references_state,\n                                                gr.State(resource_path),\n                                                resource_desc,\n                                                doc_title,\n                                                doc_description,\n                                                gr_blocks_state,\n                                            ],\n                                            outputs=[\n                                                gr.State(),\n                                                json_output,\n                                            ],  # Use dummy State to avoid re-render\n                                            trigger_mode=\"always_last\",  # Only trigger after user stops typing\n                                        )\n\n                                        delete_btn.click(\n                                            fn=delete_gradio_and_render,\n                                            inputs=[\n                                                gr_references_state,\n                                                gr.State(resource_path),\n                                                doc_title,\n                                                doc_description,\n                                                gr_blocks_state,\n                                                gr_focused_block_state,\n                                            ],\n                                            outputs=[\n                                                gr_references_state,\n                                                gr_blocks_state,\n                                                json_output,\n                                                blocks_display,\n                                            ],\n                                        )\n\n                                        # Add refresh button handler for URL resources\n                                        if is_url_resource:\n                                            refresh_btn.click(\n                                                fn=refresh_resource_from_panel,\n                                                inputs=[\n                                                    gr_references_state,\n                                                    gr.State(resource_path),\n                                                    gr.State(idx),  # resource index\n                                                    doc_title,\n                                                    doc_description,\n                                                    gr_blocks_state,\n                                                ],\n                                                outputs=[\n                                                    gr_references_state,\n                                                    gr_blocks_state,\n                                                    json_output,\n                                                ],\n                                            )\n\n                # Workspace column: AI, H, T buttons (aligned left)\n                with gr.Column(scale=1, elem_classes=\"workspace-col\"):\n                    with gr.Row(elem_classes=\"square-btn-row\"):\n                        gr_add_section_btn = gr.Button(\"+ Add Section\", elem_classes=\"add-section-btn\", size=\"sm\")\n                        # Add spacer to push collapse/expand button to the right\n                        gr.HTML(\"<div style='flex: 1;'></div>\")\n                        # Single toggle button that reflects current state\n                        # Shows double angle quote rotated to point down or up\n                        workspace_collapse_btn = gr.Button(\n                            \"\u00bb\",  # Double angle quote, rotation handled by CSS\n                            elem_classes=\"workspace-collapse-btn collapse-mode\",  # Start in collapse mode (pointing up)\n                            elem_id=\"workspace-collapse-btn\",\n                            size=\"sm\",\n                        )\n\n                    # Workspace panel for stacking content blocks\n                    with gr.Column(elem_classes=\"workspace-display\"):\n                        blocks_display = gr.HTML(\n                            value=render_blocks(initial_blocks, None), elem_classes=\"blocks-container\"\n                        )\n\n                        # Hidden components for JS communication\n                        delete_block_id = gr.Textbox(\n                            visible=True, elem_id=\"delete-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        delete_trigger = gr.Button(\n                            \"Delete\", visible=True, elem_id=\"delete-trigger\", elem_classes=\"hidden-component\"\n                        )\n\n                        # Hidden HTML for JavaScript execution\n                        gr.HTML(visible=False)\n\n                        # Hidden components for content updates\n                        update_block_id = gr.Textbox(\n                            visible=True, elem_id=\"update-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        update_content_input = gr.Textbox(\n                            visible=True, elem_id=\"update-content-input\", elem_classes=\"hidden-component\"\n                        )\n                        update_trigger = gr.Button(\n                            \"Update\", visible=True, elem_id=\"update-trigger\", elem_classes=\"hidden-component\"\n                        )\n\n                        # Hidden components for resource deletion\n                        delete_resource_path = gr.Textbox(\n                            visible=True, elem_id=\"delete-resource-path\", elem_classes=\"hidden-component\"\n                        )\n                        delete_resource_trigger = gr.Button(\n                            \"Delete Resource\",\n                            visible=True,\n                            elem_id=\"delete-resource-trigger\",\n                            elem_classes=\"hidden-component\",\n                        )\n\n                        # Hidden components for toggle collapse\n                        toggle_block_id = gr.Textbox(\n                            visible=True, elem_id=\"toggle-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        toggle_trigger = gr.Button(\n                            \"Toggle\", visible=True, elem_id=\"toggle-trigger\", elem_classes=\"hidden-component\"\n                        )\n\n                        # Hidden components for heading updates\n                        update_heading_block_id = gr.Textbox(\n                            visible=True, elem_id=\"update-heading-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        update_heading_input = gr.Textbox(\n                            visible=True, elem_id=\"update-heading-input\", elem_classes=\"hidden-component\"\n                        )\n                        update_heading_trigger = gr.Button(\n                            \"Update Heading\",\n                            visible=True,\n                            elem_id=\"update-heading-trigger\",\n                            elem_classes=\"hidden-component\",\n                        )\n\n                        # Hidden components for indent updates\n                        indent_block_id = gr.Textbox(\n                            visible=True, elem_id=\"indent-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        indent_direction = gr.Textbox(\n                            visible=True, elem_id=\"indent-direction\", elem_classes=\"hidden-component\"\n                        )\n                        indent_trigger = gr.Button(\n                            \"Update Indent\", visible=True, elem_id=\"indent-trigger\", elem_classes=\"hidden-component\"\n                        )\n\n                        # Hidden components for focus tracking\n                        focus_block_id = gr.Textbox(\n                            visible=True, elem_id=\"focus-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        focus_trigger = gr.Button(\n                            \"Set Focus\", visible=True, elem_id=\"focus-trigger\", elem_classes=\"hidden-component\"\n                        )\n\n                        # Hidden components for adding block after\n                        add_after_block_id = gr.Textbox(\n                            visible=True, elem_id=\"add-after-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        add_after_type = gr.Textbox(\n                            visible=True, elem_id=\"add-after-type\", elem_classes=\"hidden-component\"\n                        )\n                        add_after_trigger = gr.Button(\n                            \"Add After\", visible=True, elem_id=\"add-after-trigger\", elem_classes=\"hidden-component\"\n                        )\n\n                        # Hidden components for converting block type\n                        convert_block_id = gr.Textbox(\n                            visible=True, elem_id=\"convert-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        convert_type = gr.Textbox(visible=True, elem_id=\"convert-type\", elem_classes=\"hidden-component\")\n                        convert_trigger = gr.Button(\n                            \"Convert\", visible=True, elem_id=\"convert-trigger\", elem_classes=\"hidden-component\"\n                        )\n\n                        # Hidden components for updating block resources\n                        update_resources_block_id = gr.Textbox(\n                            visible=True, elem_id=\"update-resources-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        update_resources_input = gr.Textbox(\n                            visible=True, elem_id=\"update-resources-input\", elem_classes=\"hidden-component\"\n                        )\n                        update_resources_trigger = gr.Button(\n                            \"Update Resources\",\n                            visible=True,\n                            elem_id=\"update-resources-trigger\",\n                            elem_classes=\"hidden-component\",\n                        )\n\n                        # Hidden components for removing block resources\n                        remove_resource_block_id = gr.Textbox(\n                            visible=True, elem_id=\"remove-resource-block-id\", elem_classes=\"hidden-component\"\n                        )\n                        remove_resource_path = gr.Textbox(\n                            visible=True, elem_id=\"remove-resource-path\", elem_classes=\"hidden-component\"\n                        )\n                        remove_resource_trigger = gr.Button(\n                            \"Remove Resource\",\n                            visible=True,\n                            elem_id=\"remove-resource-trigger\",\n                            elem_classes=\"hidden-component\",\n                        )\n\n                        # Hidden components for deleting resources from panel\n                        delete_panel_resource_path = gr.Textbox(visible=False, elem_id=\"delete-panel-resource-path\")\n                        delete_panel_resource_trigger = gr.Button(\n                            \"Delete Panel Resource\", visible=False, elem_id=\"delete-panel-resource-trigger\"\n                        )\n\n                        # Hidden components for refreshing URL resources from panel\n                        refresh_panel_resource_path = gr.Textbox(visible=False, elem_id=\"refresh-panel-resource-path\")\n                        refresh_panel_resource_index = gr.Textbox(visible=False, elem_id=\"refresh-panel-resource-index\")\n                        refresh_panel_resource_btn = gr.Button(\n                            \"Refresh Panel Resource\", visible=False, elem_id=\"refresh-panel-resource-btn\"\n                        )\n\n                        # Hidden components for updating resource descriptions\n                        update_desc_block_id = gr.Textbox(visible=False, elem_id=\"update-desc-block-id\")\n                        update_desc_resource_path = gr.Textbox(visible=False, elem_id=\"update-desc-resource-path\")\n                        update_desc_text = gr.Textbox(visible=False, elem_id=\"update-desc-text\")\n                        update_desc_trigger = gr.Button(\n                            \"Update Description\", visible=False, elem_id=\"update-desc-trigger\"\n                        )\n\n                        # Hidden components for loading examples\n                        example_id_input = gr.Textbox(  # this shows up as textarea locally but as input deployed\n                            visible=True, elem_id=\"example-id-input\", elem_classes=\"hidden-component\"\n                        )\n                        load_example_trigger = gr.Button(\n                            \"Load Example\",\n                            visible=True,\n                            elem_id=\"load-example-trigger\",\n                            elem_classes=\"hidden-component\",\n                        )\n\n                        # Hidden components for updating resource titles\n                        update_title_resource_path = gr.Textbox(visible=False, elem_id=\"update-title-resource-path\")\n                        update_title_text = gr.Textbox(visible=False, elem_id=\"update-title-text\")\n                        update_title_trigger = gr.Button(\"Update Title\", visible=False, elem_id=\"update-title-trigger\")\n\n                        # Hidden button for updating resource panel descriptions\n                        update_panel_desc_trigger = gr.Button(\n                            \"Update Panel Description\", visible=False, elem_id=\"update-panel-desc-trigger\"\n                        )\n\n                        # Hidden components for replacing resource files\n                        replace_resource_path = gr.Textbox(visible=False, elem_id=\"replace-resource-path\")\n                        replace_resource_file_input = gr.File(\n                            visible=False,\n                            elem_id=\"replace-resource-file\",\n                            file_types=SUPPORTED_FILE_TYPES,\n                        )\n                        replace_resource_trigger = gr.Button(\n                            \"Replace Resource\", visible=False, elem_id=\"replace-resource-trigger\"\n                        )\n                        replace_success_msg = gr.Textbox(visible=False, elem_id=\"replace-success-msg\")\n\n                # Generated document column: Generate and Save Document buttons (aligned right)\n                with gr.Column(scale=1, elem_classes=\"generate-col\"):\n                    with gr.Row(elem_classes=\"generate-btn-row\"):\n                        generate_doc_btn = gr.Button(\n                            \"\u25b7 Generate\", elem_classes=\"generate-btn\", variant=\"primary\", size=\"sm\"\n                        )\n                        # Download button with dropdown container (like Template Examples)\n                        with gr.Column(elem_classes=\"download-container\"):\n                            download_btn_display = gr.Button(\n                                \"Download\",\n                                elem_classes=\"download-btn\",\n                                elem_id=\"download-btn-id\",\n                                variant=\"secondary\",\n                                size=\"sm\",\n                                visible=True,\n                                interactive=False,  # Disabled until document is generated\n                            )\n                            # Dropdown menu (hidden by default via CSS)\n                            with gr.Column(elem_classes=\"download-dropdown\", elem_id=\"download-dropdown-id\"):\n                                gr.HTML(\"\"\"\n                                    <div class=\"download-dropdown-item\" data-format=\"docx\">\n                                        <div class=\"download-title\">DOCX</div>\n                                        <div class=\"download-desc\">Word document format</div>\n                                    </div>\n                                    <div class=\"download-dropdown-item\" data-format=\"markdown\">\n                                        <div class=\"download-title\">Markdown</div>\n                                        <div class=\"download-desc\">Plain text with formatting</div>\n                                    </div>\n                                \"\"\")\n\n                    # Generated document display panel\n                    with gr.Column(elem_classes=\"generate-display\"):\n                        generated_content_html = gr.HTML(\n                            value=\"<em>Click '\u25b7 Generate' to see the generated content here.</em><br><br><br>\",\n                            elem_classes=\"generated-content\",\n                            visible=True,\n                        )\n                        generated_content = gr.Markdown(visible=False)\n\n                        # Hidden components for download functionality\n                        docx_file_path = gr.State(None)\n                        markdown_file_path = gr.State(None)\n                        download_format_trigger = gr.Button(\n                            visible=True, elem_id=\"download-format-trigger\", elem_classes=\"hidden-component\"\n                        )\n                        download_format_input = gr.Textbox(\n                            visible=True, elem_id=\"download-format-input\", elem_classes=\"hidden-component\"\n                        )\n                        # Hidden download button for actual downloads\n                        save_doc_btn = gr.DownloadButton(\n                            visible=True, elem_id=\"hidden-download-btn\", elem_classes=\"hidden-component\"\n                        )\n\n                    # Debug panel for JSON display (collapsible)\n                    with gr.Column(elem_classes=\"debug-panel\", elem_id=\"debug-panel-container\"):\n                        with gr.Row(elem_classes=\"debug-panel-header\"):\n                            gr.HTML(\"\"\"\n                                <div class=\"debug-panel-title\" onclick=\"toggleDebugPanel()\">\n                                    <span>Debug Panel (JSON Output)</span>\n                                    <span class=\"debug-collapse-icon\" id=\"debug-collapse-icon\">\u2335</span>\n                                </div>\n                            \"\"\")\n\n                        with gr.Column(elem_classes=\"debug-panel-content\", elem_id=\"debug-panel-content\", visible=True):\n                            json_output = gr.Code(\n                                value=initial_json,\n                                language=\"json\",\n                                elem_classes=\"json-debug-output\",\n                                wrap_lines=True,\n                                lines=20,\n                            )\n\n        # Connect button click to add AI block\n        gr_add_section_btn.click(\n            fn=handle_add_ai_block_top,\n            inputs=[\n                gr_blocks_state,\n                gr.State(None),\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],  # Always pass None for focused_block_id\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Connect workspace collapse/expand toggle button\n        workspace_collapse_btn.click(\n            fn=toggle_all_blocks, inputs=[gr_blocks_state], outputs=[gr_blocks_state, workspace_collapse_btn]\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Connect button click to add Text block\n\n        # Delete block handler\n        delete_trigger.click(\n            fn=delete_block,\n            inputs=[gr_blocks_state, delete_block_id, doc_title, doc_description, gr_references_state],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Delete resource handler\n        delete_resource_trigger.click(\n            fn=delete_resource_gradio,\n            inputs=[gr_references_state, delete_resource_path, doc_title, doc_description, gr_blocks_state],\n            outputs=[gr_references_state, gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Update block content handler\n        update_trigger.click(\n            fn=update_block_content,\n            inputs=[\n                gr_blocks_state,\n                update_block_id,\n                update_content_input,\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=set_focused_block, inputs=update_block_id, outputs=gr_focused_block_state)\n\n        # Toggle collapse handler - also update the collapse/expand all button\n        toggle_trigger.click(\n            fn=toggle_block_collapse, inputs=[gr_blocks_state, toggle_block_id], outputs=gr_blocks_state\n        ).then(fn=set_focused_block, inputs=toggle_block_id, outputs=gr_focused_block_state).then(\n            fn=render_blocks, inputs=[gr_blocks_state, toggle_block_id], outputs=blocks_display\n        ).then(fn=update_collapse_button_state, inputs=[gr_blocks_state], outputs=workspace_collapse_btn)\n\n        # Update heading handler\n        update_heading_trigger.click(\n            fn=update_block_heading,\n            inputs=[\n                gr_blocks_state,\n                update_heading_block_id,\n                update_heading_input,\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=set_focused_block, inputs=update_heading_block_id, outputs=gr_focused_block_state)\n\n        # Update indent handler\n        indent_trigger.click(\n            fn=update_block_indent,\n            inputs=[\n                gr_blocks_state,\n                indent_block_id,\n                indent_direction,\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display).then(\n            fn=set_focused_block, inputs=indent_block_id, outputs=gr_focused_block_state\n        )\n\n        # Focus handler\n        focus_trigger.click(fn=set_focused_block, inputs=focus_block_id, outputs=gr_focused_block_state).then(\n            fn=render_blocks, inputs=[gr_blocks_state, focus_block_id], outputs=blocks_display\n        )\n\n        # Add after handler - for + button on content blocks\n        def handle_add_after(blocks, block_id, block_type, title, description, resources):\n            if block_type == \"ai\":\n                blocks = add_ai_block(blocks, block_id)\n            else:\n                blocks = add_text_block(blocks, block_id)\n\n            # Regenerate outline JSON\n            json_str = generate_outline_json_from_state(title, description, resources, blocks)\n            return blocks, json_str\n\n        add_after_trigger.click(\n            fn=handle_add_after,\n            inputs=[\n                gr_blocks_state,\n                add_after_block_id,\n                add_after_type,\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Convert block type handler\n        convert_trigger.click(\n            fn=convert_block_type,\n            inputs=[gr_blocks_state, convert_block_id, convert_type, doc_title, doc_description, gr_references_state],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Update block resources handler\n        update_resources_trigger.click(\n            fn=update_block_resources,\n            inputs=[\n                gr_blocks_state,\n                update_resources_block_id,\n                update_resources_input,\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Remove block resource handler\n        remove_resource_trigger.click(\n            fn=remove_block_resource,\n            inputs=[\n                gr_blocks_state,\n                remove_resource_block_id,\n                remove_resource_path,\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],\n            outputs=[gr_blocks_state, json_output],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        delete_panel_resource_trigger.click(\n            fn=delete_and_render,\n            inputs=[\n                gr_references_state,\n                delete_panel_resource_path,\n                doc_title,\n                doc_description,\n                gr_blocks_state,\n                gr_focused_block_state,\n            ],\n            outputs=[gr_references_state, gr_blocks_state, json_output, blocks_display],\n        )\n\n        # Resource panel refresh handler\n        refresh_panel_resource_btn.click(\n            fn=refresh_resource_from_panel,\n            inputs=[\n                gr_references_state,\n                refresh_panel_resource_path,\n                refresh_panel_resource_index,\n                doc_title,\n                doc_description,\n                gr_blocks_state,\n            ],\n            outputs=[gr_references_state, gr_blocks_state, json_output],\n        )\n\n        # Update resource description handler - don't re-render blocks to avoid interrupting typing\n        update_desc_trigger.click(\n            fn=update_resource_description,\n            inputs=[\n                gr_blocks_state,\n                update_desc_block_id,\n                update_desc_resource_path,\n                update_desc_text,\n                doc_title,\n                doc_description,\n                gr_references_state,\n            ],\n            outputs=[gr_blocks_state, json_output],\n        )\n\n        # Title and description change handlers\n        doc_title.change(\n            fn=update_document_metadata,\n            inputs=[doc_title, doc_description, gr_references_state, gr_blocks_state],\n            outputs=[json_output],\n        )\n\n        doc_description.change(\n            fn=update_document_metadata,\n            inputs=[doc_title, doc_description, gr_references_state, gr_blocks_state],\n            outputs=[json_output],\n        )\n\n        # Handle file uploads (defined after json_output is created)\n        file_upload.upload(\n            fn=handle_file_upload,\n            inputs=[file_upload, gr_references_state, doc_title, doc_description, gr_blocks_state, gr_session_id],\n            outputs=[gr_references_state, file_upload, json_output, gr_session_id, file_upload_warning],\n        ).then(\n            # Force JSON update after resources render\n            fn=lambda title, desc, res, blocks: generate_outline_json_from_state(title, desc, res, blocks),\n            inputs=[doc_title, doc_description, gr_references_state, gr_blocks_state],\n            outputs=[json_output],\n        )\n\n        # Generate document handler - update to return the download button state\n\n        generate_doc_btn.click(\n            fn=lambda: [\n                gr.update(interactive=False),  # Disable generate button\n                gr.update(visible=False),  # Hide markdown content\n                gr.update(\n                    value=\"<em></em><br><br><br>\", visible=True\n                ),  # Show HTML with empty content but structure intact\n                gr.update(interactive=False),  # Disable display download button\n            ],\n            outputs=[generate_doc_btn, generated_content, generated_content_html, download_btn_display],\n        ).then(\n            fn=handle_generate_and_update_download,\n            inputs=[doc_title, doc_description, gr_references_state, gr_blocks_state, gr_session_id],\n            outputs=[\n                json_output,\n                generated_content,\n                generated_content_html,\n                save_doc_btn,\n                download_btn_display,\n                generate_doc_btn,\n                docx_file_path,\n                markdown_file_path,\n            ],\n        )\n\n        # Save button is handled directly by DownloadButton with create_docpack_from_current_state\n\n        download_format_trigger.click(\n            fn=handle_download_format,\n            inputs=[download_format_input, docx_file_path, markdown_file_path],\n            outputs=[save_doc_btn],\n        )\n\n        # Import file handler\n        import_file.change(\n            fn=import_outline,\n            inputs=[import_file, gr_session_id],\n            outputs=[\n                doc_title,\n                doc_description,\n                gr_references_state,\n                gr_blocks_state,\n                json_output,\n                import_file,  # Add import_file to outputs to clear it\n                gr_session_id,\n                generated_content_html,\n                generated_content,\n                save_doc_btn,\n            ],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Update save button value whenever outline changes\n        json_output.change(fn=lambda: gr.update(value=create_docpack_from_current_state()), outputs=save_outline_btn)\n\n        # Load example handler\n        load_example_trigger.click(\n            fn=load_example,\n            inputs=[example_id_input, gr_session_id],\n            outputs=[\n                doc_title,\n                doc_description,\n                gr_references_state,\n                gr_blocks_state,\n                json_output,\n                gr_session_id,\n                generated_content_html,\n                generated_content,\n                save_doc_btn,\n            ],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Update resource title handler - don't re-render resources to avoid interrupting typing\n        update_title_trigger.click(\n            fn=update_resource_title,\n            inputs=[\n                gr_references_state,\n                update_title_resource_path,\n                update_title_text,\n                doc_title,\n                doc_description,\n                gr_blocks_state,\n            ],\n            outputs=[gr_references_state, json_output],\n        )\n\n        # Update resource panel description handler - reuse the same inputs\n        update_panel_desc_trigger.click(\n            fn=update_resource_panel_description,\n            inputs=[\n                gr_references_state,\n                update_title_resource_path,\n                update_title_text,\n                doc_title,\n                doc_description,\n                gr_blocks_state,\n            ],\n            outputs=[gr_references_state, json_output],\n        )\n\n        replace_resource_trigger.click(\n            fn=handle_resource_replacement,\n            inputs=[\n                gr_references_state,\n                replace_resource_path,\n                replace_resource_file_input,\n                doc_title,\n                doc_description,\n                gr_blocks_state,\n                gr_session_id,\n            ],\n            outputs=[\n                gr_references_state,\n                gr_blocks_state,\n                json_output,\n                replace_success_msg,\n            ],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display).then(\n            # Clear the file input after processing\n            fn=lambda: None,\n            outputs=replace_resource_file_input,\n        )\n\n        new_doc_btn.click(\n            fn=reset_document,\n            outputs=[\n                doc_title,\n                doc_description,\n                gr_references_state,\n                gr_blocks_state,\n                json_output,\n                gr_session_id,\n                generated_content_html,\n                generated_content,\n                save_doc_btn,\n                gr_focused_block_state,\n            ],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display)\n\n        # Create a hidden HTML component for tab switching trigger\n        switch_tab_trigger = gr.HTML(\"\", visible=True, elem_id=\"switch-tab-trigger\", elem_classes=\"hidden-component\")\n\n        # Get Started button - generate docpack and switch to Draft + Generate tab\n\n        ui_start_tab_draft_btn.click(\n            fn=check_prompt_before_submit,\n            inputs=[ui_start_tab_prompt_input],\n            outputs=[ui_start_tab_error_message, ui_start_tab_draft_btn],\n            queue=False,  # Run immediately\n        ).success(\n            fn=handle_start_draft_click,\n            inputs=[ui_start_tab_prompt_input, gr_start_attached_references_state, gr_session_id],\n            outputs=[\n                doc_title,\n                doc_description,\n                gr_references_state,\n                gr_blocks_state,\n                json_output,\n                gr_session_id,\n                generated_content_html,\n                generated_content,\n                save_doc_btn,\n                switch_tab_trigger,\n                ui_start_tab_error_message,\n                ui_start_tab_prompt_input,\n                ui_start_tab_draft_btn,\n            ],\n        ).then(fn=render_blocks, inputs=[gr_blocks_state, gr_focused_block_state], outputs=blocks_display).then(\n            fn=generate_outline_json_from_state,\n            inputs=[doc_title, doc_description, gr_references_state, gr_blocks_state],\n            outputs=[json_output],\n        )\n\n        # Start tab file upload handler\n        ui_start_tab_file_upload.upload(\n            fn=handle_ui_start_tab_file_upload_with_render,\n            inputs=[ui_start_tab_file_upload, gr_start_attached_references_state],\n            outputs=[\n                gr_start_attached_references_state,\n                ui_start_tab_file_upload,\n                ui_start_tab_attached_references_display,\n                ui_start_tab_upload_warning,\n            ],\n        )\n\n        # URL submit handler\n        ui_start_tab_url_submit_btn.click(\n            fn=handle_ui_start_tab_url_submit_with_render,\n            inputs=[ui_start_tab_url_input, gr_start_attached_references_state],\n            outputs=[\n                gr_start_attached_references_state,\n                ui_start_tab_url_input,\n                ui_start_tab_attached_references_display,\n                ui_start_tab_url_warning,\n            ],\n        )\n\n        # Clear error message when user starts typing\n        ui_start_tab_prompt_input.input(\n            fn=lambda: gr.update(visible=False), outputs=[ui_start_tab_error_message], queue=False\n        )\n\n        ui_start_tab_example_code_readme_btn.click(\n            fn=load_code_readme_example,\n            inputs=[gr_session_id],\n            outputs=[\n                ui_start_tab_prompt_input,\n                gr_start_attached_references_state,\n                gr_session_id,\n                ui_start_tab_attached_references_display,\n            ],\n            queue=False,\n        )\n\n        ui_start_tab_example_product_launch_btn.click(\n            fn=load_product_launch_example,\n            inputs=[gr_session_id],\n            outputs=[\n                ui_start_tab_prompt_input,\n                gr_start_attached_references_state,\n                gr_session_id,\n                ui_start_tab_attached_references_display,\n            ],\n            queue=False,\n        )\n\n        ui_start_tab_example_performance_review_btn.click(\n            fn=load_performance_review_example,\n            inputs=[gr_session_id],\n            outputs=[\n                ui_start_tab_prompt_input,\n                gr_start_attached_references_state,\n                gr_session_id,\n                ui_start_tab_attached_references_display,\n            ],\n            queue=False,\n        )\n\n        # Hidden inputs for Start tab resource removal\n        start_remove_resource_index = gr.Textbox(\n            elem_id=\"start-remove-resource-index\", visible=True, elem_classes=\"hidden-component\"\n        )\n        start_remove_resource_name = gr.Textbox(\n            elem_id=\"start-remove-resource-name\", visible=True, elem_classes=\"hidden-component\"\n        )\n        start_remove_resource_btn = gr.Button(\n            \"Remove\", elem_id=\"start-remove-resource-btn\", visible=True, elem_classes=\"hidden-component\"\n        )\n\n        # Hidden inputs for Start tab URL resource refresh\n        start_refresh_url_index = gr.Textbox(\n            elem_id=\"start-refresh-url-index\", visible=True, elem_classes=\"hidden-component\"\n        )\n        start_refresh_url_name = gr.Textbox(\n            elem_id=\"start-refresh-url-name\", visible=True, elem_classes=\"hidden-component\"\n        )\n        start_refresh_url_btn = gr.Button(\n            \"Refresh URL\", elem_id=\"start-refresh-url-btn\", visible=True, elem_classes=\"hidden-component\"\n        )\n\n        # Start tab resource removal handler\n        start_remove_resource_btn.click(\n            fn=remove_start_resource,\n            inputs=[gr_start_attached_references_state, start_remove_resource_index, start_remove_resource_name],\n            outputs=[gr_start_attached_references_state, ui_start_tab_attached_references_display],\n        )\n\n        # Start tab URL resource refresh handler\n        start_refresh_url_btn.click(\n            fn=handle_refresh_start_url_resource,\n            inputs=[start_refresh_url_index, gr_start_attached_references_state],\n            outputs=[\n                gr_start_attached_references_state,\n                ui_start_tab_attached_references_display,\n                ui_start_tab_url_warning,\n            ],\n        )\n\n    return app\n\n\ndef check_deployment_status():\n    \"\"\"Quick deployment status check.\"\"\"\n    # Verify essential configuration\n    app_root = Path(__file__).resolve().parents[1]\n    bundled_recipe_path = app_root / \"document_generator_app\" / \"recipes\" / \"document_generator_recipe.json\"\n\n    print(\"Document Generator starting...\")\n    print(f\"Recipe source: {'bundled' if bundled_recipe_path.exists() else 'development'}\")\n\n    # Show LLM provider configuration\n    provider = os.getenv(\"LLM_PROVIDER\", \"openai\")\n    model = os.getenv(\"DEFAULT_MODEL\", \"gpt-4o\")\n    print(f\"LLM: {provider}/{model}\")\n\n\ndef main():\n    \"\"\"Main entry point for the Document Builder app.\"\"\"\n    global IS_DEV_MODE\n\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Document Generator App\")\n    parser.add_argument(\"--dev\", action=\"store_true\", help=\"Run in development mode\")\n    args = parser.parse_args()\n\n    # Set global dev mode variable\n    IS_DEV_MODE = args.dev\n\n    # Load environment variables from .env file\n    load_dotenv()\n\n    # Run diagnostic check\n    check_deployment_status()\n\n    # Configuration for hosting - Azure App Service uses PORT environment variable\n    if args.dev:\n        print(\"Running in DEVELOPMENT mode\")\n\n    # Production mode settings\n    server_name = os.getenv(\"GRADIO_SERVER_NAME\", \"0.0.0.0\")\n    server_port = int(os.getenv(\"PORT\", os.getenv(\"GRADIO_SERVER_PORT\", \"8000\")))\n\n    print(f\"Server: {server_name}:{server_port}\")\n\n    app = create_app()\n\n    import logging\n\n    if args.dev:\n        logging.basicConfig(level=logging.DEBUG)\n        app.launch(server_name=server_name, server_port=server_port, mcp_server=True, pwa=True, share=False)\n    else:\n        logging.basicConfig(level=logging.INFO)\n        app.launch(server_name=server_name, server_port=server_port, mcp_server=True, pwa=True)\n\n\nif __name__ == \"__main__\":\n    main()\n\n# Test line for hook - seventeenth test\n",
      "hash": "30a31c10537e31fc228937a770d8efcf",
      "modified": 1757632053.2096071
    },
    "apps/document-generator/document_generator_app/static": {
      "type": "directory"
    },
    "apps/document-generator/document_generator_app/static/css": {
      "type": "directory"
    },
    "apps/document-generator/document_generator_app/static/images": {
      "type": "directory"
    },
    "apps/document-generator/document_generator_app/static/js": {
      "type": "directory"
    },
    "apps/document-generator/document_generator_app/executor": {
      "type": "directory"
    },
    "apps/document-generator/document_generator_app/executor/__init__.py": {
      "content": "\"\"\"\nExecutor package for Document Generator.\n\"\"\"\n\n__all__ = [\"generate_document\"]\nfrom .runner import generate_document\n",
      "hash": "df31f131495e32e2e6379295052595d5",
      "modified": 1753121548.330161
    },
    "apps/document-generator/document_generator_app/executor/runner.py": {
      "content": "\"\"\"\nHeadless generation runner: invoke the document-generator recipe.\n\"\"\"\n\nimport json\nimport logging\nimport os\nimport traceback\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\nfrom recipe_executor.config import load_configuration\nfrom recipe_executor.context import Context\nfrom recipe_executor.executor import Executor\nfrom recipe_executor.logger import init_logger\n\nfrom ..config import settings\nfrom ..models.outline import Outline, Resource\nfrom ..resource_resolver import resolve_all_resources\nfrom ..session import session_manager\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nasync def generate_document(\n    outline: Optional[Outline], session_id: Optional[str] = None, dev_mode: bool = False\n) -> str:\n    \"\"\"\n    Run the document-generator recipe with the given outline and return the generated Markdown.\n    \"\"\"\n    logger.info(f\"Starting document generation for session: {session_id}\")\n    logger.info(f\"Running in {'development' if dev_mode else 'production'} mode\")\n\n    # Allow stub invocation without an outline for initial tests\n    if outline is None:\n        logger.warning(\"No outline provided, returning empty document\")\n        return \"\"\n\n    # First try bundled recipes (for deployment), then fall back to repo structure (for development)\n    APP_ROOT = Path(__file__).resolve().parents[2]  # document_generator_app parent\n    BUNDLED_RECIPE_PATH = APP_ROOT / \"document_generator_app\" / \"recipes\" / \"document_generator_recipe.json\"\n\n    logger.info(f\"APP_ROOT: {APP_ROOT}\")\n    logger.info(f\"BUNDLED_RECIPE_PATH: {BUNDLED_RECIPE_PATH}\")\n    logger.info(f\"Bundled recipe exists: {BUNDLED_RECIPE_PATH.exists()}\")\n\n    if BUNDLED_RECIPE_PATH.exists():\n        # Use bundled recipes (deployment mode)\n        RECIPE_PATH = BUNDLED_RECIPE_PATH\n        RECIPE_ROOT = RECIPE_PATH.parent\n        logger.info(f\"Using bundled recipes: {RECIPE_PATH}\")\n    else:\n        # Fall back to repo structure (development mode)\n        REPO_ROOT = Path(__file__).resolve().parents[4]\n        RECIPE_PATH = REPO_ROOT / \"recipes\" / \"document_generator\" / \"document_generator_recipe.json\"\n        RECIPE_ROOT = RECIPE_PATH.parent\n        logger.info(f\"Using repo recipes: {RECIPE_PATH}\")\n        logger.info(f\"Recipe exists: {RECIPE_PATH.exists()}\")\n\n    # Use session-scoped temp directory\n    session_dir = session_manager.get_session_dir(session_id)\n    tmpdir = str(session_dir / \"execution\")\n    Path(tmpdir).mkdir(exist_ok=True)\n    logger.info(f\"Using temp directory: {tmpdir}\")\n\n    try:\n        # Resolve all resources using the new resolver\n        logger.info(\"Resolving resources...\")\n        outline_data = outline.to_dict()\n        logger.info(f\"Outline data: {json.dumps(outline_data, indent=2)}\")\n\n        resolved_resources = resolve_all_resources(outline_data, session_id)\n        logger.info(f\"Resolved resources: {resolved_resources}\")\n\n        # Update resource paths in outline with resolved paths, converting docx to text if needed\n        for resource in outline.resources:\n            if resource.key in resolved_resources:\n                old_path = resource.path\n                resolved_path = str(resolved_resources[resource.key])\n\n                # Always update the path to the resolved path (keeps original file reference)\n                resource.path = resolved_path\n\n                # If it's a docx file, convert it to text and save as .txt file\n                if resolved_path.lower().endswith(\".docx\"):\n                    try:\n                        from ..app import docx_to_text\n\n                        text_content = docx_to_text(resolved_path)\n\n                        # Create a text file version\n                        txt_path = resolved_path.replace(\".docx\", \".txt\")\n                        with open(txt_path, \"w\", encoding=\"utf-8\") as f:\n                            f.write(text_content)\n\n                        # Set txt_path for recipe executor to use\n                        resource.txt_path = txt_path\n                        logger.info(\n                            f\"Converted docx to text: {resource.key}: {old_path} -> {resolved_path}, txt_path: {txt_path}\"\n                        )\n                    except Exception as e:\n                        filename = os.path.basename(resolved_path)\n                        logger.error(f\"Error converting docx file {filename}: {e}\")\n                        # Re-raise with user-friendly message if it's a protection issue\n                        if \"protected or encrypted\" in str(e):\n                            raise e  # Error already includes filename from docx_to_text\n                        # Keep txt_path as None on other errors\n                else:\n                    logger.info(f\"Updated resource {resource.key}: {old_path} -> {resource.path}\")\n\n        # Create updated outline for recipe execution (use txt_path when available)\n        execution_outline = Outline(\n            title=outline.title,\n            general_instruction=outline.general_instruction,\n            resources=[\n                Resource(\n                    key=res.key,\n                    path=res.txt_path if res.txt_path else res.path,  # Use txt_path for recipe execution\n                    title=res.title,\n                    description=res.description,\n                    merge_mode=res.merge_mode,\n                    txt_path=res.txt_path,\n                )\n                for res in outline.resources\n            ],\n            sections=outline.sections,\n        )\n\n        data = execution_outline.to_dict()\n        outline_json = json.dumps(data, indent=2)\n        outline_path = Path(tmpdir) / \"outline.json\"\n        outline_path.write_text(outline_json)\n        logger.info(f\"Created outline file for recipe execution: {outline_path}\")\n\n        recipe_logger = init_logger(log_dir=tmpdir)\n\n        # Load configuration from environment variables\n        config = load_configuration()\n\n        context = Context(\n            artifacts={\n                \"outline_file\": str(outline_path),\n                \"recipe_root\": str(RECIPE_ROOT),\n                \"output_root\": str(session_dir),  # Use session directory for output\n                \"model\": settings.model_id,  # Use configured model\n            },\n            config=config,  # Pass configuration to context\n        )\n        logger.info(f\"Context artifacts: {context.dict()}\")\n\n        executor = Executor(recipe_logger)\n        logger.info(f\"Executing recipe: {RECIPE_PATH}\")\n        await executor.execute(str(RECIPE_PATH), context)\n        logger.info(\"Recipe execution completed\")\n\n        output_root = Path(context.get(\"output_root\", tmpdir))\n        filename = context.get(\"document_filename\")\n        logger.info(f\"Output root: {output_root}\")\n        logger.info(f\"Document filename: {filename}\")\n        logger.info(f\"All context keys: {list(context.keys())}\")\n\n        if not filename:\n            document_content = context.get(\"document\", \"\")\n            logger.info(f\"No filename, returning document from context (length: {len(document_content)})\")\n            return document_content\n\n        document_path = output_root / f\"{filename}.md\"\n        logger.info(f\"Looking for document at: {document_path}\")\n\n        try:\n            content = document_path.read_text()\n            logger.info(f\"Successfully read document (length: {len(content)})\")\n            return content\n        except FileNotFoundError:\n            logger.error(f\"Generated file not found: {document_path}\")\n            # List files in output directory for debugging\n            if output_root.exists():\n                files = list(output_root.glob(\"*\"))\n                logger.info(f\"Files in output directory: {files}\")\n            return f\"Generated file not found: {document_path}\"\n    except Exception as e:\n        logger.error(f\"Error generating document: {str(e)}\")\n        logger.error(f\"Full traceback: {traceback.format_exc()}\")\n        return f\"Error generating document: {str(e)}\\n\\nFull traceback:\\n{traceback.format_exc()}\"\n\n\nasync def generate_docpack_from_prompt(\n    prompt: str, resources: List[Dict[str, str]], session_id: Optional[str] = None, dev_mode: bool = False\n) -> Tuple[str, str]:\n    \"\"\"\n    Generate a docpack outline from user prompt and uploaded resources.\n\n    Args:\n        prompt: User's description of the document they want to create\n        resources: List of uploaded resource files with 'path' and 'name' keys\n        session_id: Optional session ID for file management\n        dev_mode: Whether running in development mode\n\n    Returns:\n        Tuple of (docpack_path, outline_json) where:\n        - docpack_path: Path to the generated .docpack file\n        - outline_json: JSON string of the generated outline\n    \"\"\"\n    logger.info(f\"Starting docpack generation for session: {session_id}\")\n    logger.info(f\"Running in {'development' if dev_mode else 'production'} mode\")\n    logger.info(f\"Prompt: {prompt}\")\n    logger.info(f\"Resources: {len(resources)} files\")\n\n    # Setup paths\n    APP_ROOT = Path(__file__).resolve().parents[2]\n    BUNDLED_RECIPE_PATH = APP_ROOT / \"document_generator_app\" / \"recipes\" / \"generate_docpack.json\"\n\n    logger.info(f\"APP_ROOT: {APP_ROOT}\")\n    logger.info(f\"BUNDLED_RECIPE_PATH: {BUNDLED_RECIPE_PATH}\")\n    logger.info(f\"Bundled recipe exists: {BUNDLED_RECIPE_PATH.exists()}\")\n\n    if BUNDLED_RECIPE_PATH.exists():\n        RECIPE_PATH = BUNDLED_RECIPE_PATH\n        RECIPE_ROOT = RECIPE_PATH.parent\n        logger.info(f\"Using bundled recipes: {RECIPE_PATH}\")\n    else:\n        # Fall back to repo structure\n        REPO_ROOT = Path(__file__).resolve().parents[4]\n        RECIPE_PATH = REPO_ROOT / \"recipes\" / \"document_generator\" / \"generate_docpack.json\"\n        RECIPE_ROOT = RECIPE_PATH.parent\n        logger.info(f\"Using repo recipes: {RECIPE_PATH}\")\n\n    # Use session-scoped temp directory\n    session_dir = session_manager.get_session_dir(session_id)\n    tmpdir = str(session_dir / \"docpack_generation\")\n    Path(tmpdir).mkdir(exist_ok=True)\n    logger.info(f\"Using temp directory: {tmpdir}\")\n\n    try:\n        # Extract resource paths and convert docx to text if needed\n        # Keep track of original paths and their converted versions\n        resource_paths = []\n        docx_conversion_map = {}  # Maps txt_path -> original_docx_path\n\n        for resource in resources:\n            if \"path\" in resource and resource[\"path\"]:\n                resource_path = resource[\"path\"]\n\n                # If it's a docx file, convert it to text and save as .txt file\n                if resource_path.lower().endswith(\".docx\"):\n                    try:\n                        from ..app import docx_to_text\n\n                        text_content = docx_to_text(resource_path)\n\n                        # Create a text file version\n                        txt_path = resource_path.replace(\".docx\", \".txt\")\n                        with open(txt_path, \"w\", encoding=\"utf-8\") as f:\n                            f.write(text_content)\n\n                        resource_paths.append(txt_path)\n                        docx_conversion_map[txt_path] = resource_path  # Remember the original path\n                        logger.info(f\"Converted docx to text: {resource_path} -> {txt_path}\")\n                    except Exception as e:\n                        logger.error(f\"Error converting docx file {resource_path}: {e}\")\n                        # Re-raise with user-friendly message if it's a protection issue\n                        if \"protected or encrypted\" in str(e):\n                            raise e\n                        resource_paths.append(resource_path)  # Fall back to original path for other errors\n                else:\n                    resource_paths.append(resource_path)\n\n        logger.info(f\"Resource paths: {resource_paths}\")\n\n        # Initialize recipe logger\n        recipe_logger = init_logger(log_dir=tmpdir)\n\n        # Load configuration\n        config = load_configuration()\n\n        # Create timestamp-based docpack name\n        from datetime import datetime\n\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        docpack_name = f\"{timestamp}.docpack\"\n\n        # Create context for the recipe\n        context = Context(\n            artifacts={\n                \"model\": settings.model_id,\n                \"output_root\": str(session_dir),\n                \"document_description\": prompt,\n                \"resources\": resource_paths,\n                \"docpack_name\": docpack_name,\n                \"recipe_root\": str(RECIPE_ROOT),\n            },\n            config=config,\n        )\n        logger.info(f\"Context artifacts: {context.dict()}\")\n\n        # Execute the generate_docpack recipe\n        executor = Executor(recipe_logger)\n        logger.info(f\"Executing recipe: {RECIPE_PATH}\")\n        await executor.execute(str(RECIPE_PATH), context)\n        logger.info(\"Recipe execution completed\")\n\n        # Get the generated files\n        output_root = Path(context.get(\"output_root\", tmpdir))\n        docpack_path = output_root / docpack_name\n        outline_path = output_root / \"outline.json\"\n\n        # Read the generated outline and fix docx paths\n        outline_json = \"\"\n        if outline_path.exists():\n            outline_json = outline_path.read_text()\n            logger.info(f\"Generated outline loaded from: {outline_path}\")\n\n            # If we have docx conversions, fix the paths in the outline\n            if docx_conversion_map:\n                try:\n                    import json\n\n                    outline_data = json.loads(outline_json)\n\n                    # Fix resource paths to point back to original docx files\n                    for resource in outline_data.get(\"resources\", []):\n                        resource_path = resource.get(\"path\", \"\")\n                        if resource_path in docx_conversion_map:\n                            original_path = docx_conversion_map[resource_path]\n                            logger.info(f\"Restoring original path: {resource_path} -> {original_path}\")\n                            resource[\"path\"] = original_path  # Restore original docx path\n                            resource[\"txt_path\"] = resource_path  # Keep txt path for future use\n\n                    # Save the fixed outline\n                    outline_json = json.dumps(outline_data, indent=2)\n                    logger.info(\"Fixed outline paths to preserve original docx references\")\n\n                except Exception as e:\n                    logger.error(f\"Error fixing outline paths: {e}\")\n                    # Continue with original outline_json if fixing fails\n\n        else:\n            logger.error(f\"Outline file not found at: {outline_path}\")\n\n        # Check if docpack was created\n        if not docpack_path.exists():\n            logger.error(f\"Docpack file not found at: {docpack_path}\")\n            # List files for debugging\n            if output_root.exists():\n                files = list(output_root.glob(\"*\"))\n                logger.info(f\"Files in output directory: {files}\")\n            return \"\", outline_json\n\n        logger.info(f\"Successfully generated docpack at: {docpack_path}\")\n        return str(docpack_path), outline_json\n\n    except Exception as e:\n        logger.error(f\"Error generating docpack: {str(e)}\")\n        logger.error(f\"Full traceback: {traceback.format_exc()}\")\n        raise\n",
      "hash": "a7efcf2e2cab04daf918fb931903d546",
      "modified": 1757114302.1186216
    },
    "apps/document-generator/document_generator_app/models": {
      "type": "directory"
    },
    "apps/document-generator/document_generator_app/models/__init__.py": {
      "content": "\"\"\"\nModels package for Document Generator.\n\"\"\"\n\n__all__ = [\"Resource\", \"Section\", \"Outline\"]\nfrom .outline import Resource, Section, Outline\n",
      "hash": "185bba9d5ee16c3f35a63cec549c2ab4",
      "modified": 1753121548.3344948
    },
    "apps/document-generator/document_generator_app/models/outline.py": {
      "content": "\"\"\"\nData models for the Document Generator app.\nDefines Resource, Section, and Outline dataclasses with serialization utilities.\n\"\"\"\n\nfrom dataclasses import dataclass, field, asdict\nfrom typing import List, Optional, Dict, Any\nfrom jsonschema import validate\n\n\n@dataclass\nclass Resource:\n    key: str\n    path: str\n    title: str\n    description: str\n    merge_mode: str\n    txt_path: Optional[str] = None  # Path to converted text file (for docx files)\n    resource_type: Optional[str] = None  # \"file\" or \"url\"\n    source_url: Optional[str] = None  # Original URL for URL resources\n\n\n@dataclass\nclass Section:\n    title: str\n    prompt: Optional[str] = None\n    refs: List[str] = field(default_factory=list)\n    resource_key: Optional[str] = None\n    sections: List[\"Section\"] = field(default_factory=list)\n    _mode: Optional[str] = field(default=None, init=False, repr=False)  # Internal mode tracking\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert to dict, excluding None values and empty refs to match schema.\"\"\"\n        result: Dict[str, Any] = {\"title\": self.title}\n\n        # Use mode to determine which fields to include\n        if self._mode == \"Static\" and self.resource_key is not None:\n            result[\"resource_key\"] = self.resource_key\n        else:\n            # Default to prompt mode\n            if self.prompt is not None:\n                result[\"prompt\"] = self.prompt\n            if self.refs:  # Only include refs if not empty\n                result[\"refs\"] = self.refs\n\n        # Always include sections array (even if empty)\n        result[\"sections\"] = [s.to_dict() for s in self.sections]\n\n        return result\n\n\ndef section_from_dict(data: Dict[str, Any]) -> Section:\n    section = Section(\n        title=data.get(\"title\", \"\"),\n        prompt=data.get(\"prompt\"),\n        refs=list(data.get(\"refs\", [])),\n        resource_key=data.get(\"resource_key\"),\n        sections=[section_from_dict(s) for s in data.get(\"sections\", [])],\n    )\n    # Set mode based on loaded data\n    if section.resource_key is not None:\n        section._mode = \"Static\"\n    else:\n        section._mode = \"Prompt\"\n    return section\n\n\n@dataclass\nclass Outline:\n    title: str\n    general_instruction: str\n    resources: List[Resource] = field(default_factory=list)\n    sections: List[Section] = field(default_factory=list)\n\n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"Convert outline to dict with proper section serialization.\"\"\"\n        return {\n            \"title\": self.title,\n            \"general_instruction\": self.general_instruction,\n            \"resources\": [asdict(r) for r in self.resources],\n            \"sections\": [s.to_dict() for s in self.sections],\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"Outline\":\n        res_list: List[Resource] = []\n        for r in data.get(\"resources\", []):\n            res_list.append(\n                Resource(\n                    key=r.get(\"key\", \"\"),\n                    path=r.get(\"path\", \"\"),\n                    title=r.get(\"title\", \"\"),\n                    description=r.get(\"description\", \"\"),\n                    merge_mode=r.get(\"merge_mode\", \"concat\"),\n                    txt_path=r.get(\"txt_path\"),\n                    resource_type=r.get(\"resource_type\"),\n                    source_url=r.get(\"source_url\"),\n                )\n            )\n        sec_list: List[Section] = [section_from_dict(s) for s in data.get(\"sections\", [])]\n        return cls(\n            title=data.get(\"title\", \"\"),\n            general_instruction=data.get(\"general_instruction\", \"\"),\n            resources=res_list,\n            sections=sec_list,\n        )\n\n\n# JSON Schema for outline validation\nOUTLINE_SCHEMA = {\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"Outline\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"title\": {\"type\": \"string\"},\n        \"general_instruction\": {\"type\": \"string\"},\n        \"resources\": {\n            \"type\": \"array\",\n            \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"key\": {\"type\": \"string\"},\n                    \"path\": {\"type\": \"string\"},\n                    \"title\": {\"type\": \"string\"},\n                    \"description\": {\"type\": \"string\"},\n                    \"merge_mode\": {\"type\": \"string\", \"enum\": [\"concat\", \"dict\"]},\n                    \"txt_path\": {\"type\": \"string\"},\n                    \"resource_type\": {\"type\": \"string\", \"enum\": [\"file\", \"url\"]},\n                    \"source_url\": {\"type\": \"string\"},\n                },\n                \"required\": [\"key\", \"path\", \"title\", \"description\"],\n                \"additionalProperties\": False,\n            },\n        },\n        \"sections\": {\"type\": \"array\", \"items\": {\"$ref\": \"#/definitions/section\"}},\n    },\n    \"definitions\": {\n        \"section\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"title\": {\"type\": \"string\"},\n                \"prompt\": {\"type\": \"string\"},\n                \"refs\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n                \"resource_key\": {\"type\": \"string\"},\n                \"sections\": {\"type\": \"array\", \"items\": {\"$ref\": \"#/definitions/section\"}},\n            },\n            \"required\": [\"title\"],\n            \"oneOf\": [{\"required\": [\"prompt\"]}, {\"required\": [\"resource_key\"]}],\n            \"additionalProperties\": False,\n        }\n    },\n    \"required\": [\"title\", \"general_instruction\", \"resources\", \"sections\"],\n    \"additionalProperties\": False,\n}\n\n\ndef validate_outline(data: dict) -> None:\n    \"\"\"\n    Validate outline data against the JSON schema.\n    Raises jsonschema.ValidationError on failure.\n    \"\"\"\n    validate(instance=data, schema=OUTLINE_SCHEMA)\n",
      "hash": "409d6d9476fde91311101b9e18368e95",
      "modified": 1757543715.9167318
    }
  }
}